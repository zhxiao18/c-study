# C++笔记

## 常用知识

- normal 模式下，光标定位在字符串，`[2/3]shift+k `，打开man手册。

- gdb调试：

  - `b 函数名/行号` 打断点
  - `i` 查看相关信息
  - `i b` 查看断点信息
  - `r` 运行， `s `下一步， `n/f` 调出循环

- `:bn` 下一个文件     `:bp `上一个文件

- `d$`：删除到行尾。

- `shift+%`：切换括号。

- `sudo apt install lrzsz`。

- Makefile

  - ```c++
    srcs:=$(wildcard *.cc)
    exes:=$(srcs:%.cc=%)
    all:$(exes)
    %:%.cc
    	g++ $^ -o $@ -g
    ```

## C++Day01

### 一、入门程序

- 头文件

  ```c++
  //C++的头文件 都是用模板进行编写的，而模板有一个特点:必须要在编译的时候才能实现
  // 没有 .h
  #include <iostream>
  ```

- `hello world`

```c++
int main(void){
	//cout:输出流对象		<<:输出流运算符		"hello world"：字符串常量		operator<<：重载运算符
    cout << "hello world" << endl; 				//	=>等价下一行		
    operator<<(cout, "hello world").operator<<(endl);
       
    int number = 0;
    //cin:输入流对象
    //>>：输入流运算符
    cin >> number;	// =>等价下一行
    cin.operator>>(number);
    
   return 0;
}
```

- C++头文件的路径

```c++
/usr/include/c++
```

### 二、命名空间

- **FHCPPProjectAPrint();**这是C语言中的写法

- 为了解决名字冲突，可以使用命名空间。

#### 1、基本用法

- 所谓命名空间就是一个可以由用户自己定义的作用域，在不同的作用域中可以定义相同名字的变量，互不干扰，系统能够区分它们。

#####  1.1 命名空间的声明

- 命名空间中可以定义变量、函数、类、命名空间、结构体，统称为实体。
- 编程规范：定义实体不用缩进，实体内正常缩进。

```c
using std::cin;
using std::endl;
using std::cout;

namespace wd{ 
int num = 100;
void myPrintf(){
    cout<<"wd的输出"<<endl;
}
} // end wd

int main()
{
    wd::myPrintf();
    cout<<wd::num<<endl;
    return 0;
}
```

##### 1.2 命名空间的作用

- 避免命名冲突：命名空间提供了一种将全局作用域划分成更小的作用域的机制，用于避免不同的代码中可能发生的命名冲突问题。

- 组织代码：将相关的实体放到同一个命名空间。

- 版本控制：不同版本的代码放到不同的命名空间中

总之，需要用到代码分隔的情况就可以考虑使用命名空间。

隐藏的好处：声明主权。

#### 2、三种使用形式

##### 1、using编译指令

- 1.1 优缺点
  - 优点：简洁。
  - 缺点：会一次引入该命名空间的所有实体，可能会发生冲突。
  - using编译指令之后，再次使用作用域限定符，不会有问题。

- 1.2 代码

```c
namespace wd{
int num = 100;

void myPrintf(){
	cout<<"using 编译指令实现命名空间"<<endl;
}
} //end wd

//使用using编译指令使用命名空间
using namespace wd;

int main(){
    myPrintf();
    cout<<num<<endl;
}
```

##### 2、作用域限定符

- 2.1 优缺点
  - 优点：准确，只要命名空间有实体存在，不会出错
  - 缺点：繁琐。

- 2.2 代码

```c
namespace wd{ 
int num = 100;
void myPrintf(){
    cout<<"wd的输出"<<endl;
}
} //end wd

int main()
{
    //使用 :: 作用域限定符
    wd::myPrintf();
    cout<<wd::num<<endl;
    return 0;
}
```

##### 3、using声明机制

- 3.1 推荐
  - 明确声明会用到的命名空间中的某些实体，可以避免程序员重复定义同名函数。

- 3.2 代码

```c
using std::cout;
using std::cin;
using std::endl;

namespace wd{ 
int num = 100;
void myPrintf(){
    cout<<"wd的输出"<<endl;
}
} //end wd

using wd::myPrintf;
using wd::num;

int main(void){
    myPrintf();
    cout<<"using声明机制："<<num<<endl;
}
```

#### 

#### 3、命名空间的扩展

<img src="47期C++笔记.assets/image-20230320153258168.png" alt="image-20230320153258168" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230802165646355.png" alt="image-20230802165646355" style="zoom: 80%;" /><img src="47期C++笔记.assets/image-20230320155545138.png" alt="image-20230320155545138" style="zoom:50%;" />

#### 4、匿名命名空间

1.1 注意事项

- 匿名命名空间中不要定义与全局空间同名的实体，全局空间的值会覆盖匿名空间的值。
- 匿名命名空间属于命名空间。
- 匿名命名空间可以对诸如`printf`的函数进行改写。

1.2 代码

```c
using std::cout;
using std::cin;
using std::endl;

namespace{
void printf(const char* name, int a){
    cout<<"name:"<<name<<endl;
    cout<<"a = "<<a<<endl;
}
}

int main(void){
    printf("zhangsan", 3);
    return 0;
}
```

<img src="../../桌面/c++/MarkDown/C++ MarkDown/C++基础.assets/image-20230729162140272.png" alt="image-20230729162140272" style="zoom: 67%;" />

#### 5、命名空间的嵌套

<img src="47期C++笔记.assets/image-20230320161842122.png" alt="image-20230320161842122" style="zoom:50%;" />

### 三、const用法

#### 1、const修饰普通变量

1、 定义

- `const`修饰的变量是常量，常量在定义的时候必须要进行初始化。
- C语言中定义常量：**宏定义**，宏定义是没有类型检查的，容易出错																		。

2、 `const`关键字与宏定义的区别（面试题）

- 编译器处理方式不同。宏定义是在预处理阶段进行替换，而`const`常量是在编译时。
- 类型和安全检查不同。宏定义没有类型，不做任何检查；`const`常量有具体的类型，在编译期间会执行类型检查。C++中更倾向于使用`const`常量。

**内置类型**

<img src="47期C++笔记.assets/image-20230320165217138.png" alt="image-20230320165217138" style="zoom:50%;" />

#### 2、const修饰指针

- 常量指针
  - 本质是一个指针，一个指向常量的指针。
  - 特点：指针的指向可以修改，但是指针指向的值不可以修改。

```c
int num1 = 10, num2 = 20;
const int *p = &num1;
/* *p = 0; //error */
 p = &num2;
```

- 指针常量
  - 常量的性质是施加在指针上。
  - 特点：指针的指向不可以修改，但是指针指向的值可以修改。

```c
//指针常量
int num1 = 10, num2= 20;
int *const p = &num1;
*p = 0;                                                            
/* p = &num2;  //error */
```

- 双重const
  - `const`既修饰指针，又修饰常量：`const int * const p = &a;`。
  - 特点：指针的指向和指针的值都不可以修改。

-  数组指针
  - 一个指向数组的指针

```c
int arr[5] = {1,2,3,4,5};                                          
int (*p)[5] = &arr;	//5不能省略，表示申请多大的内存
//*p = arr
```

- 指针数组
  - 数组里面的每一个元素都是指针。

```c
//指针数组
int num1 = 10, num2 = 20, num3 = 30;
int *p1 = &num1, *p2 = &num2, *p3 = &num3;

int *arr[3] = {p1, p2, p3};

for(int i = 0; i < 3; i ++){
    cout << *arr[i] << endl;
 }
// 10 20 30
```

- 函数指针
  - 一个指向函数的指针。

```c
  //函数指针
  int add(int x, int y){ 
      return x + y;
  }
  int (*p)(int, int) = add;

  void test02(){
      cout << p(5,6) << endl;
  }
```

- 指针函数
  - 返回值类型为指针的函数。

```c
  //指针函数
  int sum = 0;

  int * add(int x, int y){
      sum = x + y;
      return &sum;
  }  

  void test03(){
      cout << *add(5,5) << endl;
  } 
```

## C++Day02

### 一、问题回顾

1、命名空间有哪三种使用形式？都有什么特点？命名空间是扩展是什么？标准命名空间可以扩展吗？

2、匿名命名空间？命名空间的嵌套？

3、const修饰普通变量的特点？const修饰指针的特点？

4、什么是函数指针与指针函数？

### 二、new与delete表达式

#### 1、C申请堆空间数组

<img src="47期C++笔记.assets/image-20230321101703596.png" alt="image-20230321101703596" style="zoom:50%;" />

#### 2、C++中申请堆空间数组

- new申请变量

```c
int *p1 = new int();	//声明未初始化,默认为0
cout << *p1 <<endl;

int *p2 = new int(100);		//初始化为100
cout << *p2 << endl;
```

- delete回收变量

```c
delete p1; //释放内存
```

##### 面试题

> new/delete表达式与malloc/free的区别是？
>
> 1）malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符或表达式 ；
>
> 2）new能够自动分配空间大小，malloc需要传入参数；
>
> 3）new开辟空间的同时还对空间做了初始化的操作；而malloc不行，里面存的是脏数据。
>
> 4）new/delete能对对象进行构造和析构函数的调用，进而对内存进行更加详细的工作，而malloc/free不能。
>
> 5）都需要成对出现，否则有可能造成内存泄漏。

- new申请数组空间

```c
int *arr = new int[5]();	//编程规范：()一定要带；在老旧版本中，不带()代表未进行初始化，存在脏数据
```

- 回收数组

```c
delete [] arr;	//代表回收数组空间
```

- 安全回收

```c
delete p1; //释放内存
p1 = nullptr;	//把p1设为空指针，安全回收操作
```

堆空间数组

https://www.cnblogs.com/tp-16b/p/8684298.html

### 三、引用(重要)

#### 1、基本概念

- 定义
  - 本质是一个变量的别名，引用本身不能单独存在，在定义的时候必须初始化。
  - `类型 & ref = 变量`。
  - 引用一经绑定无法修改绑定。
  - 引用的底层实现就是一个指针常量`（* const）`。

  ```c
  int number = 10;
  int &ref = number;
  
  cout << ref << endl;		//10
  
  cout << &number << endl;	//相同
  cout << &ref << endl;
  
  ref = 100;
  cout << number << endl;		//100
  ```

> 引用与指针的联系与区别
>
> 联系：
>
> ​	1、引用和指针都有地址的概念，都是用来间接访问变量。
>
> ​	2、引用的底层还是指针来完成，可以把指针看做一个受限的指针。
>
> 区别：
>
> ​	1、引用不能单独存在，指针可以单独存在。
>
> ​	2、引用必须初始化，指针可以不初始化。
>
> ​	3、引用一经绑定，不能换绑；指针可以随意更改指向（指针太灵活）。
>
> ​	4、引用简单理解为不占据额外内存，引用的地址即变量本身的地址；而指针在内存中占据的空间是存储地址所需的字节数。
>
> 引用设计初衷：少用指针。

#### 2、引用作为函数参数

```c
//值传递=>拷贝副本，如果将int换成其他类型(struct)，会有拷贝开销
//不改变形参的值
void swap(int x, int y){
    int tmp = x;
    x = y;
    y = tmp;
}

//地址传递，直观性不太好
//改变形参的值,传给swap两个地址，通过地址改变其指向的内容
void swap(int * x, int * y){
    int tmp = *x;
    *y = *x;
    *x = tmp;
}

//引用传递：直观性好，指针大小固定，
//最简洁高效的办法，对引用进行操作等同于对变量本身进行操作；这里不会发生拷贝
void swap(int & x, int & y){
    int tmp = x;
    x = y;
    y = tmp;
}
```

#### 3、引用作为函数返回类型

- 代码

```c
//func2返回int,执行return时,会复制产生一个临时变量，执行这个函数时会用一下，当这个函数执行完毕时这个临时变量就被销毁了，无法对其取值。
int func2(){
    cout << "func2 number" << number << endl;
    return number;
}

int number = 10;

//func1的返回类型是int的引用，执行return时，不会发生复制，减少拷贝操作
int & func1(){
    cout << "func1 number" << number << endl;
	return number;
}

int arr[5] = {1,2,3,4,5};                                                    
int &getIdx(int idx){
    return arr[idx];
}

void test02(){
    cout << "getIdx[0] = " << getIdx(0) << endl;
    getIdx(0) = 10; 
    cout << "arr[0] = " << arr[0] << endl;
    cout << "getIdx[0] = " << getIdx(0) << endl;
}
```

- 易错点
  - 不要返回局部变量的引用。
  - 返回类型为引用时，要确保引用绑定的变量生命周期比函数更长。
  - 不要轻易返回堆空间变量的引用，非常容易发生内存泄漏，回收起来很麻烦。

<img src="47期C++笔记.assets/image-20230321115120822.png" alt="image-20230321115120822" style="zoom:50%;" />

#### 4、vimplus环境配置的问题

配置相应代码的模板。

<img src="47期C++笔记.assets/image-20230321143505557.png" alt="image-20230321143505557" style="zoom:55%;" /><img src="47期C++笔记.assets/image-20230806123114628.png" alt="image-20230806123114628" style="zoom:80%;" />

```C++
//.bashrc 显示短路径
export PS1='\[\e[36;47m\]\u\[\e[33;47m\]@\[\e[36;47m\]\h\[\e[35;47m\]:\[\e[31;47m\]\W\[\e[00m\]\$ '
```

### 四、强制转换

#### 1、static_cast

```c
void test01(){
    int i_number = 19; 
    double d_number = 10.3;

    //1.把double类型转换成int型
    i_number = static_cast<int>(d_number);
    cout << "i_number = " << i_number << endl;	// 10l
    cout << "-----------------------" << endl;

    //2.把int*型转换成void*型                                                  
    int *pInt = new int(12);
    void *pVoid = static_cast<void*>(pInt);
    cout << pVoid << endl;
    delete pInt;
    pInt = nullptr;
}
```

- 有类型检查：`static_cast`对强制转换做了一些区分，不允许一些出错转换发生。
- 方便查找。

#### 2、const_cast

- 可以去除常量属性。

```c++
void test02(){
    const int number = 10; 
    /* int *pInt = &number; */  //error, number is const
    int *pInt = const_cast<int*>(&number);
    *pInt = 20;         //未定义行为,不支持

    cout << "number = " << number << endl;      //10
    cout << "*pInt = " << *pInt << endl;        //20                         

    printf("&number = %p\n", &number);          //0x7ffc0259f47c
    printf("pInt = %p\n", pInt);                //0x7ffc0259f47c  
}
//--------------------------------------------
void func(int * x){
	*x = 100;	//完成了修改，但是并没有放回内存中，而是放在了寄存器中
    cout << "*x = " << *x <<endl;
}

const int number = 100;
func(&number);	//错误，func函数需要接收的是一个普通的int*

func(const_cast<int *>(&number));		//去除const属性
```

对于未定义行为的理解

https://www.cnblogs.com/QG-whz/p/4513136.htm

### 五、函数重载

#### 1、定义

- 在同一个**作用域**中，**函数的名字**相同，但是函数的**参数列表不一样**（参数的类型、参数的个数、参数顺序）。

```c
int add(int x, int y){};
int add(int x, int y, int z){};
int add(long x, int y){};
int add(int x, long y）{}；
```

- **查看文件类型的命令**

<img src="47期C++笔记.assets/image-20230321152609711.png" alt="image-20230321152609711" style="zoom:50%;" />

- 实现原理：名字改编，当函数名相同时，会根据参数的类型、顺序、个数进行改编。

  - 函数返回值不能作为函数重载的条件。

```C++
wangdao@wangdao:overload$ nm add.o	//nm add.o  
                 U __cxa_atexit
                 U __dso_handle
                 U _GLOBAL_OFFSET_TABLE_
00000000000001ab t _GLOBAL__sub_I__Z3addii
00000000000000a6 T main
0000000000000068 T _Z3addff		//名字改编
0000000000000082 T _Z3addfff
000000000000004c T _Z3addfi
0000000000000030 T _Z3addif
0000000000000000 T _Z3addii
0000000000000014 T _Z3addiii
0000000000000162 t _Z41__static_initialization_and_destruction_0ii
                 U _ZNSolsEi
                 U _ZNSolsEPFRSoS_E
                 U _ZNSt8ios_base4InitC1Ev
                 U _ZNSt8ios_base4InitD1Ev
                 U _ZSt4cout
                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_
0000000000000000 r _ZStL19piecewise_construct
0000000000000000 b _ZStL8__ioinit
                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
```

<img src="47期C++笔记.assets/image-20230321153332782.png" alt="image-20230321153332782" style="zoom:50%;" />

#### extern

<img src="47期C++笔记.assets/image-20230321161926769.png" alt="image-20230321161926769" style="zoom:50%;" />

### 六、默认参数

- 若不给参数传递实参，则函数会按指定的默认值进行工作。允许函数设置默认参数值，是为了让编程简单，让编译器做更多的检查错误工作。
- 默认值赋值：从右往左连续赋值。
- c/c++而言，函数参数的入栈顺序是:从右往左。

```c
int add(int x= 10, y = 8){
    cout << "x + y = " << x+y << endl;
}

add();   //18
add(0);  //8
```

### 七、bool类型

- bool类型可以使用true与false进行体现，然后bool占用一个字节大小空间（可以作为标志位使用）。
- 除了0代表假，其他都代表真。

```C++
sizeof(bool) = 1;
```

### 八、内联函数

- 宏函数
  - 优点：只是进行字符串的替换，没有函数调用的开销。
  - 缺点：没有类型检查，存在安全隐患，每一个变量都应该加（）。

- inline函数声明
  -  在普通函数前加上`inline`关键字。

```c
inline int add(int x = 10, int y = 8){
    cout << "x + y = " << x+y << endl;
} 
```

- 会进行类型检查。

- 只能放在头文件中定义，因为在**编译**的时候会进行字符串替换；如果在头文件中没有实现，程序找不到替换字符串会报错，并不会真正生成一个函数入口。

- **inline**函数本质也是字符串替换（编译时），不用进行函数调用的入栈出栈，所以不会增加开销。
- **inline**函数不适合放大量代码，放止出现代码膨胀。

#### 头文件与实现文件

<img src="47期C++笔记.assets/image-20230321172601027.png" alt="image-20230321172601027" style="zoom: 50%;" />

**Tips：**

- 内联函数一般不建议使用while/for这种复杂语句，也不建议函数的嵌套使用，内联函数本质上就是一些小函数。

### 九、异常安全

```c++
  void test01(){
      int x, y;
      cin >> x >> y;
      
      try{
          if(0 == y){ 	//标准写法
              throw y;
          }else{
              cout << "(x/y) = " << x/y << endl;
          }   
      }
      catch(int x){ //catch的是数据类型
          cout << "catch(x)" << endl;
      }
      catch(double y){ 
          cout << "double(y)" << endl;
      }   
  }

[zx@ubuntu ~/programs/c++Base]$ ./a.out 
21
3
(x/y) = 7
[zx@ubuntu ~/programs/c++Base]$ ./a.out 
12
0
catch(x)
```

## C++Day03

### 一、问题回顾

1、申请堆空间的方式有哪些？有什么区别？

2、引用的基本性质有哪些？引用是什么类型的指针？引用的两种使用场景？

3、函数重载的定义是什么？原理是什么？步骤是什么？

4、如何查看一段代码是C代码还是C++代码？

5、默认参数在使用时候需要注意什么？

6、内联函数的特点？在使用时候需要注意什么？

7、异常安全中的三个关键字是什么？如何结合在一起使用？

### 二、C/C++风格字符串

#### 调试代码的两种常用方法

1、使用常规的printf或者cout进行打印，然后定位代码出错的位置。

2、使用业界常用的方法，gdb调试。

常用的命令：-g选项，是调试选项；list简写为l，列出源代码；run简写为r，让程序运行起来；bt打印堆栈信息；b可以进行打断点。

<img src="47期C++笔记.assets/image-20230322103420825.png" alt="image-20230322103420825" style="zoom:50%;" />

#### C语言中字符串的两种形式

```c
void test01(){
    //1、字符数组
    char str1[] = "hello";
    str1[0] = 'R';	//可以修改指针的值
    /* str1 = nullptr;     //指针常量，不能修改指针的指向
    cout << "str1:" << str1 << endl;
    
    
    //2、字符指针
    const char * str2 = "Hello";
    /* str2[0] = 'h'; */        //常量指针，不能修改值
    cout << "str2:" << str2 << endl;
    str2 = "wangdao";		//可以修改指向
    cout << "str2:" << str2 << endl; 
}  
```

#### C++风格字符串

```c++
void test01(){
    string str1 = "hello";
    string str2 = "world";
    string str3 = str1 + str2;      //不需要考虑内存
    cout << "str1: " << str1 <<endl		// str1:hello
        << "str2: " << str2 << endl		// str2:world
        << "str3: " << str3 << endl;	// str3: helloworld

    //将C++风格字符串转换为c风格字符串
    const char * pstr = str3.c_str();
    cout << "pstr: " << pstr << endl;	// pstr: helloworld

    //获取C++风格字符串的长度
    int len1 = str3.size();
    cout << "str len1 = " << len1 << endl;	// str len1 = 10
    int len2 = str3.length();
    cout << "str len2 = " << len2 << endl;	// str len2 = 10

    //遍历C++字符串
    for(int i = 0; i != str3.size(); i++){
        cout << str3[i] << "  ";			// h  e  l  l  o  w  o  r  l  d
    }
    cout << endl;

    //字符串拼接
    string str4 = str3 + " wangdao";
    cout << "str4 : " <<  str4 << endl;		// str4 : helloworld wangdao

    string str5 = str4 + 'A';
    cout << "str5: " << str5 << endl;		// str5: helloworld wangdaoA

    str5.append(str1);
    cout << "str5: " << str5 << endl;		// str5: helloworld wangdaoAhello
}
```

```C++
//部分重载
template< class CharT, class Traits, class Alloc >basic_string<CharT,Traits,Alloc>
operator+( const basic_string<CharT,Traits,Alloc>& lhs,const basic_string<CharT,Traits,Alloc>& rhs );

template< class CharT, class Traits, class Alloc >basic_string<CharT,Traits,Alloc>
operator+( const basic_string<CharT,Traits,Alloc>& lhs,const CharT* rhs );
```

### 三、C/C++内存分配方式

32位系统为例，2^32 = 4G，分配4G的地址空间（虚拟地址空间）。

- 3G-4G：内核空间。

- 0-3G：用户态空间。

- 栈区：栈变量、栈对象。局部变量、函数的参数。**编译器**进行自动分配与释放。

- 堆区：`malloc/calloc/new`申请的空间都是堆空间。需要**程序员**进行申请与释放，如果程序员不回收，那么os可能会进行回收。

- 全局静态区（读写区）：
  - 全局变量：初始化与未初始化的。
  - 静态变量：初始化与未初始化的。static修饰的

- 只读区：
  - 文字常量区，可以存放字符串常量。"hello,world"。
  - 程序代码区，程序的二进制代码。

  <img src="47期C++笔记.assets/image-20230807113123439.png" alt="image-20230807113123439" style="zoom:55%;" /><img src="../../桌面/c++/MarkDown/C++ MarkDown/C++基础.assets/image-20230801214210855.png" alt="image-20230801214210855" style="zoom:70%;" />

  ```c
  int g_number = 10; 	//在全局区，默认为0
  const int kMax = 100;	// *文字常量区
  
  void test(){
      int l_number = 20; 	//栈区，默认初始值随机
      static int s_number = 30; 	//静态区
      const char* p = "point string";	//文字常量区
      char * pstr = new char[10]();	//pstr本身位于栈上，但是pstr所指变量位于堆上
      const char *phello = "hello world";  //phello 本身位于栈上，但phello所指的字符串在文字常量区
  
      cout << "临时变量(栈区)：&l_number:" << &l_number << endl;
      cout << "(指针地址，栈区)&p:" << &p << endl;
      printf("(堆区)pstr:%p\n", pstr);
      cout << "全局变量：&g_number:" << &g_number << endl;
      cout << "(静态变量)&static:" << &s_number << endl;
      printf("(文字常量)&p:%p\n", p); 
      cout << "(程序代码)&test():" << &test << endl;
      
      const int kMin = 1;	//	*在栈上的常量
  }
                                                                                  
  int main()
  {
      test();
      cout << "(程序代码)&main():" << &main << endl;
      return 0;
  }	
  ```


## C++Day04

### 一、类的基本概念

面向过程语言：C语言，模块化，按照事物发展的逻辑顺序推进事物的发展。

面向对象的语言：C++语言，四大基本特征：抽象、封装、继承、多态。



面向过程：

1、三个兄弟来到旅馆，分别交100块给老板。

2、老板将300元中的50元交给店员，让店员等会将钱返给三兄弟。

3、店员将50元中的30元交给三兄弟。



面向对象：

将五个人看成是五个不同的对象，让对象之间去进行交互，使得彼此之间的状态发生变化。

将具有相同属性的**对象**抽象出来，于是就形成了**类**。（抽象的过程）类实例化之后就会形成对象（具体）

```C++
class 类名                       
{
public://共有的，可以对外提供的
    //数据成员（属性、特征）
    //成员函数（行为、方法，操作属性的方法）
protected://保护的，留给儿子使用
     //数据成员（属性、特征）
    //成员函数（行为、方法，操作属性的方法）
private://私有的，留给自己使用
    //数据成员（属性、特征）
    //成员函数（行为、方法，操作属性的方法）
};

人:人的特征或者属性；交互的行为与方法。
```

```C++
#include <string.h>
#include <iostream>

using std::cout;
using std::endl;

//C++中将struct的功能做了提升，可以在其中定义函数；然后在C++
//中struct与class区别在于：默认访问权限的问题，struct默认访问权限是public，而class的默认访问权限是private

class Computer
{
    //左大括号到右大括号称为类的内部
public:
    //三个方法、行为;成员函数
    void setBrand(const char *brand)
    {
        //越界的风险
        strcpy(_brand, brand);
    }

    void setPrice(float price)
    {
        _price = price;
    }

    void print()
    {
        cout << "_brand = " << _brand << endl
             << "_price = " << _price << endl;
    }

private://封装性，不能在类的外面进行访问
    //两个属性;数据成员
    char _brand[20];//品牌
    float _price;//价格
};//分号不能去掉

int main(int argc, char **argv)
{
    int a;
    //使用类Computer创建对象com
    Computer com;
    com.setBrand("ThinkPad");
    com.setPrice(5300);
    com.print();

    /* com._price = 6000;//error,使用private封装性 */

    return 0;
}
```

<img src="47期C++笔记.assets/image-20230323144916127.png" alt="image-20230323144916127" style="zoom:50%;" />

**注意**：写在一个文件或者写在类中的成员函数，默认都是inline函数（内联函数）。

##### 编程规范

- 类的命名遵守**驼峰**规则。
- 数据成员命名以`_`开头。
- 成员函数命名遵循**小驼峰**规则。
- 类中只保留类的声明，类的实现放在类外。

### 二、对象的创建

#### 构造函数

<img src="47期C++笔记.assets/image-20230323155922345.png" alt="image-20230323155922345" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230323172301338.png" alt="image-20230323172301338" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230323155937813.png" alt="image-20230323155937813" style="zoom:50%;" />



**麻烦点**：

​													<img src="47期C++笔记.assets/image-20230323163050194.png" alt="image-20230323163050194" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230809155407924.png" alt="image-20230809155407924" style="zoom:67%;" />

### 三、初始化表达式

<img src="47期C++笔记.assets/image-20230323160621048.png" alt="image-20230323160621048" style="zoom:50%;" />

### 四、对象的销毁

​						<img src="47期C++笔记.assets/image-20230323162954344.png" alt="image-20230323162954344" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230323163013584.png" alt="image-20230323163013584" style="zoom: 60%;" />

<img src="47期C++笔记.assets/image-20230323165217886.png" alt="image-20230323165217886" style="zoom: 50%;" />

#### 析构函数的调用时机

1、栈对象，对象在离开作用域被销毁时候，自动调用析构函数。
2、全局、静态对象，在离开作用域被销毁的时候，自动调用析构函数。
3、**堆对象**，必须要**手动的执行delete操作**，才能调用析构函数。

<img src="47期C++笔记.assets/image-20230323171949783.png" alt="image-20230323171949783" style="zoom: 55%;" />

### 五、拷贝构造函数

#### 形式

<img src="47期C++笔记.assets/image-20230323180253252.png" alt="image-20230323180253252" style="zoom: 50%;" />

#### 浅拷贝与深拷贝

- 浅拷贝可能会出现**double free**的问题。

<img src="47期C++笔记.assets/image-20230323180355390.png" alt="image-20230323180355390" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230323175748207.png" alt="image-20230323175748207" style="zoom:50%;" />

## C++Day05

### 一、问题回顾

1、用户态空间分为哪些区域？有什么特点？

栈区

堆区

读写段：全局变量、静态变量。

只读段：文字常量区、程序代码区。



2、对象创建会调用什么函数？该函数的形态是怎么样的？有什么作用？有什么特点？

```C++
class Point
{
public:
  //构造函数的重载
  Point()
  : _ix(0)//初始化表达式（列表）
  , _iy(0)
  {
      
  }
    
  Point(int ix, int iy)
  : _ix(ix)
  , _iy(iy)
  {
      
  }
  
  //Point pt2 = pt;//const Point &rhs = pt
  Point(const Point &rhs)
  : _ix(rhs._ix)
  , _iy(rhs._iy)
  {
      
  }
    
  void print()
  {
      
  }
  
  //唯一性
  ~Point()
  {
      
  }
    
private:
    int _ix;
    int _iy;
};

void test()
{
    Point pt(1, 2);
    pt.print();
    
    Point();
    
    pt.~Point();//ok
    
    //int a = 10;
    //int b = a;
    Point pt2 = pt;//拷贝（复制）构造函数
}
```

3、C++中类中数据成员的初始化在哪里？有什么注意事项？

4、对象销毁会调用什么函数？该函数的形态是怎么样的？有什么作用？有什么特点？

5、深拷贝与浅拷贝的区别？

6、拷贝构造函数的形式？

### 二、拷贝构造函数（重要）

#### 1、拷贝构造函数调用时机(重点)

​						<img src="47期C++笔记.assets/image-20230324095432794.png" alt="image-20230324095432794" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230324100201641.png" alt="image-20230324100201641" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230324102424618.png" alt="image-20230324102424618" style="zoom:50%;" />

- `func3`是临时对象，不能取地址，一般取地址是为了使用，但是其生命周期只有这一行，后面再使用地址是无意义的，所以编译器禁止取地址。
- `Point & func3`引用作为返回类型也可以避免复制，但是把局部对象绑定到引用上作为返回值是不安全的：再利用这个函数的返回值调用函数成员会发生段错误（访问已经被销毁的成员）

#### 2、拷贝构造函数的参数问题

##### 左值、右值

- 左值：可以进行取地址的称为左值。
- 右值：不能进行取地址的称为右值。右值包括：临时对象、匿名对象、临时变量、匿名变量、字面值常量（10）

##### 参数问题

- Q1:拷贝构造函数参数中的引用符号能不能去掉?|

  > 引用符号不能去掉，因为如果去掉引用符号，那么在进行形参与实参结合的时候，会调用拷贝构造函数，而拷贝构造函数现在没有引用符号，那么就是用一个已经存在的对象初始化一个刚刚创建的对象，也就是满足拷贝构造函数的调用时机1，!会继续无限的调用拷贝构造函数，而函数的参数是会入栈的，而栈是有大小的，这样就将栈压垮，导致栈溢出。

- Q2:拷贝构造函数是否可以去掉const？

  > 不能去掉，当执行拷贝构造函数的时候，如果传递进来的参数是右值的时候，会出现非const左值引用不能绑定到右值就会出现错误。 (注意:没有const的时候， 传递的参数是左值是没有问题)。此外，确保右操作数的数据成员不被改变。

​						<img src="47期C++笔记.assets/image-20230803220207172.png" alt="image-20230803220207172" style="zoom:80%;" /><img src="47期C++笔记.assets/image-20230324113812924.png" alt="image-20230324113812924" style="zoom:50%;" />

### 三、this指针

<img src="47期C++笔记.assets/image-20230324115238861.png" alt="image-20230324115238861" style="zoom:50%;" />

### 四、赋值运算符函数（重要）

#### 1、形态

​									<img src="47期C++笔记.assets/image-20230324152151687.png" alt="image-20230324152151687" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230803220636671.png" alt="image-20230803220636671" style="zoom:67%;" />

#### 2、四部曲

```c
Computer &Computer::operator=(const Computer &rhs)
{
	cout << "Computer &operator=( const Computer &)" << endl;
    
    /* if(不是自己赋值给自己) */
    /* if(*this != rhs) */
	if(this != &rhs)		//1、自复制，防止自己赋值给自己
        delete [] _brand;	  //2、 释放左操作数。解决内存泄漏
        _brand = nu11ptr;
    
        //3、 深拷贝，防止内存越界
        _ brand = new char[str1en(rhs._brand) + 1]();
        strcpy(_brand, rhs._brand);
        _price = rhs._ price;
	}

	return  *this;	//4、 返回*this
}
```

#### 3、参数问题

<img src="47期C++笔记.assets/image-20230324153716913.png" alt="image-20230324153716913" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230803112210277.png" alt="image-20230803112210277" style="zoom:67%;" />

#### 4、三合成原则（重要）

- 拷贝构造函数、赋值运算符函数、析构函数，如果需要手动定义其中的一个，那么另外两个都需要手动定义。

### 五、四种特殊数据成员初始化

#### 1、常量数据成员

- 必须要在初始化列表中进行初始化，并且不能进行赋值。

<img src="47期C++笔记.assets/image-20230324160320368.png" alt="image-20230324160320368" style="zoom:59%;" /><img src="47期C++笔记.assets/image-20230324160237928.png" alt="image-20230324160237928" style="zoom:50%;" />

#### 2、引用数据成员

- 引用数据成员 必须在*初始化列表*中进行初始化。

```c
class Point{
public:
    Point(int ix, int iy)
    :_ix(ix),
    _iy(iy),
    ref(_ix)		//必须在初始化列表进行初始化
    {                                                                        
        ref = _ix;
        cout << "Point init" << endl;
    }   
private:
    int _ix;
    int _iy;
    int & ref;
};
```

<img src="47期C++笔记.assets/image-20230324161656629.png" alt="image-20230324161656629" style="zoom:50%;" />

```c
cout << "sizeof(ref)" <<  sizeof(ref) << endl;    // 4
```

- 空类也是占用大小的

<img src="47期C++笔记.assets/image-20230324162512107.png" alt="image-20230324162512107" style="zoom:50%;" />

- 代码（包括成员函数）会放到*程序代码区*供所有的类的对象共享。

#### 3、类对象数据成员

- 子对象：将一个类所创建的对象作为另一个类的数据成员。

- 类对象数据成员：初始化也是在初始化列表中。

```c
class Point{
public:
    Point(int x, int y)
    :_x(x),
    _y(y)
    {
        cout << "Point init" << endl;
    }

    void print(){
        cout << "(" << _x << "," << _y << ")" ;
    }

    ~Point(){
        cout << "~Point" << endl;
    }
private:
    int _x;
    int _y;
};

class Line{
public:
    Line(int x1, int y1, int x2, int y2)
    :_p1(x1, y1),		//类对象数据成员的初始化也要放到`初始化列表`中去
    _p2(x2, y2)
    {
        cout << "Line init" << endl;
    }

    void print(){
        _p1.print();
        cout << "---->";
        _p2.print();
        cout << endl;
    }

    ~Line(){
        cout << "~Line" << endl;
    }
private:
    Point _p1;			//类对象
    Point _p2;
};

void test01(){
    Line line(1,2, 3, 4);
    line.print();
}
```

#### 4、静态数据成员（难点）

- **静态数据成员不能在初始化列表中进行初始化，否则会报错**。静态数据成员可以不受访问权限的控制。

<img src="47期C++笔记.assets/image-20230324165632771.png" alt="image-20230324165632771" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230324164804731.png" alt="image-20230324164804731" style="zoom:50%;" />

- 如果有多个静态成员，需要按声明的顺序来初始化。

### 六、特殊的成员函数

#### 1、静态成员函数

##### 特点

- 1、对于静态成员函数而言，其第一个参数的位置没有隐含的this。
- 2、静态的成员函数不能访问非静态的数据成员与非静态的成员函数。
- 3、非静态的成员函数可以访问静态的数据成员与静态的成员函数。
- 4、如果静态的成员函数想访问非静态的数据成员或者成员函数，可以使用函数传参的形式，或者在静态成员函数体中创建对象。
- 5、静态成员函数可以使用类名与作用域限定符的形式进行调用(独特之处，其他的非静态成员函数不能这么调用)。

- 6、静态成员函数声明需要加上static关键字，而实现的时候不需要。

<img src="47期C++笔记.assets/image-20230803140219091.png" alt="image-20230803140219091" style="zoom:67%;" /><img src="47期C++笔记.assets/image-20230324173415399.png" alt="image-20230324173415399" style="zoom: 60%;" />

#### 2、const成员函数

##### 格式

```c
类型 函数名(参数列表) const
{
	函数体
}

const成员函数中的this指针：const Point * const this
```

<img src="47期C++笔记.assets/image-20230324175132287.png" alt="image-20230324175132287" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230803152315116.png" alt="image-20230803152315116" style="zoom: 80%;" />

##### 特点

- const成员函数中， 不能修改对象的数据成员。
- 当编译器发现该函数是const成员函数时，会自动将this指针设置为双重const限定的指针。
- 非const的对象默认情况调用的是非const版本的成员函数:而const对象调用是const版本的成员函数。
- 非const对象也是可以调用const版本的成员函数的。
- const对象是不能调用非const版本的成员函数。

> 总结：若确定成员函数中不修改数据成员，可将其设为const成员函数。

## C++Day06

### 一、问题回顾

1、拷贝构造函数有哪三种调用时机？参数中的const与引用可以去掉吗？

2、this指针的特点是什么？

3、赋值运算符函数有哪四个步骤？每步的原因是什么？参数问题？

4、特殊数据成员有哪四种？分别在哪里初始化？

5、静态成员函数的特点有哪些？

6、const成员函数的特点有哪些？

### 二、对象的组织

<img src="47期C++笔记.assets/image-20230325100646269.png" alt="image-20230325100646269" style="zoom:50%;" />

### 三、单例模式（重要）

```C++
#include <iostream>

using std::cout;
using std::endl;

//单例模式的设计需求：一个类只能有一个对象
//思路：
//1、创建的对象肯定是要入内存的，也就是用户态的那块空间
//2、不能在类外面创建对象(可以创建多个对象)，所以就在类中进行创建(将构造函数设为私有)。
//3、为了让类外的对象创建报错，将构造函数设置为私有的
//
//使用场景：全局唯一的对象，网页库、日志记录器

class Singleton
{
public:
    static Singleton *getInstance()
    {
        if(nullptr == _pInstance)
        {
            _pInstance = new Singleton();//在类中创建堆对象
        }

        return _pInstance;
    }

    static void destroy()	//防止double free
    {
        if(_pInstance)
        {
            delete _pInstance;
            _pInstance = nullptr;
        }
    }

private:
    Singleton()
    {
        cout << "Singleton()" << endl;
    }

    ~Singleton()
    {
        cout << "~Singleton()" << endl;
    }
private:
    static Singleton *_pInstance;
};

//静态数据成员的初始化
Singleton *Singleton::_pInstance = nullptr;

/* Singleton gS1;//全局区,error */
/* Singleton gS2;//全局区 */

int main(int argc, char **argv)
{
    /* Singleton s1;//栈区,error */
    /* Singleton s2;//栈区 */

    /* Singleton *ps1 = new Singleton();//堆区,error */
    /* Singleton *ps2 = new Singleton(); */

    /* printf("&s1 = %p\n", &s1); */
    /* printf("&s2 = %p\n", &s2); */
    /* printf("ps1 = %p\n", ps1); */
    /* printf("ps2 = %p\n", ps2); */

    Singleton *ps1 = Singleton::getInstance();
    Singleton *ps2 = Singleton::getInstance();
    cout << "ps1 = " << ps1 << endl;
    cout << "ps2 = " << ps2 << endl;

    /* Singleton::getInstance()->destroy(); */		//创建完立即销毁，不可行

    Singleton::destroy();	//即使多次执行destroy，也不会出现double free
    Singleton::destroy();
    Singleton::destroy();

    /* delete ps1;//error */	//double free
    /* delete ps2;//error */

    return 0;
}
```

### 四、内存对齐

#### 内存对齐解释

- 对齐规则是按照成员的声明顺序，依次安排内存，其偏移量为成员大小的整数倍，0看做任何成员的整数倍，最后结构体的大小为最大成员的整数倍。

#### 内存对齐原因

- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

#### 规则

##### 规则一：数据成员对齐规则

- 结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset(偏移)为0的地方，以后每个数据成员的对齐按照` #pragma pack `指定的数值和这个数据成员自身长度中，比较小的那个进行。

<img src="47期C++笔记.assets/image-20230809204055941.png" alt="image-20230809204055941" style="zoom: 55%;" /><img src="47期C++笔记.assets/image-20230809204157833.png" alt="image-20230809204157833" style="zoom: 55%;" />

##### 规则二：结构(或联合)的整体对齐规则

- 在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照 `#pragma pack` 指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

##### 规则三：结构体作为成员

- 如果一个结构里有某些结构体成员，则**内部结构体成员**要从成员最大元素大小的整数倍和` #pragma pack`指定的数值中最小的一个的整数倍的地址开始存储。  

  ​															<img src="47期C++笔记.assets/image-20230809214233029.png" alt="image-20230809214233029" style="zoom: 67%;" />

  ```c++
  #pragma pack(n) //对齐系数,一行存储的字节数
  ```

## C++Day07

### 一、问题回顾 

1、单例模式的设计需求？设计思路？有什么特点？使用场景？

2、内存对齐的三个规则？

### 二、new/delete表达式的工作步骤

#### 1、new表达式的三个工作步骤

1.1、执行**operator new库函数**，申请原始的未初始化的堆空间。
1.2、在该空间上构建对象。
1.3、返回执行新空间的指针。

#### 2、delete表达式的两个工作步骤

2.1、调用析构函数，将对象中的**数据成员所申请的资源进行回收**。
2.2、调用**operator delete库函数**，回收对象本身所占用的空间。

#### new/delete调用顺序（堆）

<img src="47期C++笔记.assets/image-20230803161011700.png" alt="image-20230803161011700" style="zoom: 50%;" />

- 创建堆上的对象时，使用new表达式
  - 1.先调用operator new函数申请了空间。
  - 2.再调用构造函数。
  - 3.最后返回相应类型指针。

- 销毁堆上的对象时，使用delete语句
  - 1.先调用析构函数(回收数据成员申请的堆空间)。
  - 2.调用operator delete函数回收对象本身的空间。

#### 3、特性

- 创建栈对象条件

  <img src="47期C++笔记.assets/image-20230327114235293.png" alt="image-20230327114235293" style="zoom:50%;" />

- 创建堆对象条件

<img src="47期C++笔记.assets/image-20230803162518681.png" alt="image-20230803162518681" style="zoom: 67%;" />

- 其他

<img src="47期C++笔记.assets/image-20230327112306075.png" alt="image-20230327112306075" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230327115216168.png" alt="image-20230327115216168" style="zoom:50%;" />

### 三、C++输入输出流

<img src="47期C++笔记.assets/image-20230804184750952.png" alt="image-20230804184750952" style="zoom: 75%;" />

#### 1、基本概念

- 针对不同的对象，会有不同的IO操作。针对屏幕、键盘，标准IO；针对磁盘（针对于文件），文件IO；针对于程序（内存），串IO。

##### 流的四种状态

- *badbit*，系统级别的错误，该种错误不能恢复，可以使用函数**bad**进行判断。
- *failbit*，可以恢复的错误，可以重新置位流的状态，可以使用函数**fail**进行判断。
- *eofbit*，异常，表示文件指针到达了文件末尾，可以使用函数**eof**进行判断。
- *goodbit*，流的正常状态，可以使用函数**good**进行判断。

#### 2、标准IO

- 标准输入流cin，标准输出流cout，cerr（标准错误输出，不带缓冲），clog（标准错误输出，带缓冲）。
- cout 本质：**operator<<(cout, "123").operator<<(endl)**;

- **判断流状态**

```c++
void printStreamStatus(){
    //判断流的状态
    cout << "cin.babit: " << cin.bad() << endl;
    cout << "cin.failbit: " << cin.fail() << endl;
    cout << "cin.eofbit: " << cin.eof() << endl;
    cout << "cin.goodbit: " << cin.good() << endl << endl;
}

void test01(){
    int number = 0;
    printStreamStatus();
    cin >> number;
    printStreamStatus();
    cout << "number:" << number << endl;

    //如果上面输入字符串，会导致流异常，程序中断                             
    string word;
    cin >> word;
    printStreamStatus();
    cout << "word: " << word << endl;
    printStreamStatus();
}
```

<img src="47期C++笔记.assets/image-20230804194345987.png" alt="image-20230804194345987" style="zoom:80%;" />

- 重置流状态、清空缓冲区
  - 重置流状态：clear()，清空缓冲区：ignore()。

```c++
//实现循环输入

int number = 0;
//真值表达式while(Cin)
//真值表达式转换为逗号表达式，逗号表达式的值是最后一个逗号后面的表达式的值
while(cin >> number,!cin.eof())
{
    if(cin.bad())//不能恢复的系统级别的错误
    {
        cerr << "The stream is bad" << endl;
        return ;
    }
    
    else if(cin.fail())//可以恢复的错误
    {
        cin.clear();//重置流的状态	
        //std::numeric_ limits<std::streamsize>::max() => system’s max number， need '#include<limits>'
        cin.ignore(std::numeric_ limits<std::streamsize>::max()，'\n');		//清空缓冲区
        cout << "reset stream status." << end1;
    }
    
    else
    	cout << "number: " << number << endl; 
}
```

#### 3、缓冲区

- 速度不匹配的产物。

##### 缓冲区的类型

- 全缓冲、行缓冲、无缓冲。

##### 缓冲区的刷新

- 程序正常结束的时候，会刷新缓冲区。

  - ```c
    //程序睡眠3秒钟后才输出，说明程序正常结束，刷新缓冲区
    void test01(){                                                               
        for(size_t idx = 0; idx < 1024; idx ++){
            cout << 'a' ;
        }   
        sleep(3);
    }
    ```

- 缓冲区满的时候（在ubuntu1804上缓冲区的大小正好是1024）。

  - ```c
    //缓冲区满，输出1024个a，3秒后程序结束，刷新缓冲区，输出123
    void test01(){
        for(size_t idx = 0; idx < 1024; idx ++){
            cout << 'a' ; 
        } 
        cout << "123";                                                           
        sleep(3);       
    }  
    ```

- 手动执行flush与endl，显式刷新。

  - ```c++
    using std::endl;
    using std::flush;
    
    //缓冲区满，输出1024个a，然后刷新缓冲区，直接输出123
    void test01(){
        for(size_t idx = 0; idx < 1024; idx ++){
            cout << 'a' ; 
        } 
        cout << "123" << endl;    
        cout << "123" << flush;		//刷新但是不换行
        sleep(3);       
    }  
    ```

- *endl、flush、ends*源代码

```C++
__ostream_type& operator<<(__ostream_type& (*__pf)(__ostream_type&))
{
    return __pf(*this);
}

 __ostream_type& operator<<(long __n)
{ 
     return _M_insert(__n); 
 }

__ostream_type& operator<<(unsigned long __n)
{ 
    return _M_insert(__n); 
}

 __ostream_type& operator<<(bool __n)
{ 
     return _M_insert(__n); 
 }

__ostream_type&  operator<<(short __n);
{
     return _M_insert(static_cast<unsigned long>(__n));
}

operator<<(endl);
pf = endl;//注册回调函数，（重要）

__ostream_type& operator<<(__ostream_type& (*__pf)(__ostream_type&))//函数参数结合
{
    return __pf(*this);//调用函数，回调函数的执行（重要）
}

__ostream& (*__pf)(__ostream&)

int operator<<(int (*__pf)(int));
    
int (*__pf)(int);//函数指针

template<typename _CharT, typename _Traits>
inline 
basic_ostream<_CharT, _Traits>&endl(basic_ostream<_CharT, _Traits>& __os)
{ 
    return flush(__os.put(__os.widen('\n'))); 
}

inline 
basic_ostream& flush(basic_ostream& __os)
{ 
    return __os.flush(); 
}

template<typename _CharT, typename _Traits>
inline 
basic_ostream<_CharT, _Traits>&ends(basic_ostream<_CharT, _Traits>& __os)
{ 
    return __os.put(_CharT()); 
}
```

#### 4、文件IO

- 如果想将某个成员函数删除或者不提供，可以在类中将该函数设置为私有（C++98）或者将该函数删除（=delete）(C++11)

##### 4.1、文件输入流

- **explicit**：防止隐式转换。

  ​				<img src="47期C++笔记.assets/image-20230804233251609.png" alt="image-20230804233251609" style="zoom:80%;" /><img src="47期C++笔记.assets/image-20230804233259396.png" alt="image-20230804233259396" style="zoom: 70%;" />

  - 函数声明

  ```c
  basic_ifstream();
  explicit basic_ifstream( const char* filename,std::ios_base::openmode mode = ios_base::in );
  explicit basic_ifstream( const std::string& filename,std::ios_base::openmode mode = ios_base::in );
  basic_ifstream( const basic_ifstream& rhs) = delete;	//复制构造函数被删除：此类不可复制。
  ```

  

##### 4.2 、文件输入流的特点

- 对于文件输入流而言，如果文件不存在，那么就会报错；如果文件存在，才可以进行后续的操作。
- 对于文件输入流而言，读取文件默认情况以空格为分隔符。

```c++
#include <fstream>
using std::ifstream;

void test()
{
    
    ifstream ifs("PointTmp.cc);
    if(!ifs.good())
    {
        cerr << "ifstream is not good" << endl; 
        return ;
    }
 
    while(ifs >> word)
    {
        cout << word <<" ";
    }
    cout << endl;
                 
    ifs.close();//关闭文件
}
```

- getline

```c
std::basic_istream<CharT,Traits>& getline( std::basic_istream<CharT,Traits>& input,
                                           std::basic_string<CharT,Traits,Allocator>& str );
```

```c++

```



##### 4.3、vector

<img src="47期C++笔记.assets/image-20230327173631525.png" alt="image-20230327173631525" style="zoom:50%;" />

## C++Day08

### 一、问题回顾

1、new表达式的工作步骤是什么？delete表达式的工作步骤是什么？如何理解回收对象的空间与对象中数据成员的空间？

2、对象的销毁与析构函数的执行是不是等价的？创建栈对象的条件

3、流有哪四种状态？如果流的状态fail了，那么需要执行哪些操作？

​				clear,ignore

4、缓冲区的类型以及刷新缓冲区的方式？

程序正常结束；缓冲区满；手动刷新（flush、endl）

4、文件输入流的特点是什么？

5、vector的底层原理原理是什么？

### 二、文件IO（重要）

#### 1、文件输出流

<img src="47期C++笔记.assets/image-20230328094246766.png" alt="image-20230328094246766" style="zoom:50%;" />

#### 2、文件输入输出流

<img src="47期C++笔记.assets/image-20230328101044681.png" alt="image-20230328101044681" style="zoom:50%;" />

##### 文件对象的偏移

<img src="47期C++笔记.assets/image-20230328101224262.png" alt="image-20230328101224262" style="zoom:50%;" />

##### 文件对象的位置

<img src="47期C++笔记.assets/image-20230328101242304.png" alt="image-20230328101242304" style="zoom:50%;" />

#### 3、文件模式

##### 文件输入流的追加模式

<img src="47期C++笔记.assets/image-20230328101935513.png" alt="image-20230328101935513" style="zoom:50%;" />

##### 文件输出流的追加模式

<img src="47期C++笔记.assets/image-20230328102050081.png" alt="image-20230328102050081" style="zoom:50%;" />

### 三、字符串IO

<img src="47期C++笔记.assets/image-20230328110503395.png" alt="image-20230328110503395" style="zoom:50%;" />

### 四、Log4cpp

#### 1、日志系统的重要性

- 对于服务器程序而言，是一直都在运行的（7 * 24），守护进程。没有终端进行交互，当服务器出现了问题，那如何进行查找呢？就可以去查看服务器运行过程中的日志。日志可以将服务器的运行轨迹将其记下来，等后面服务器出现问题之后，就可以进行查看。

#### 2、设计思路

- 日志库的设计，一般而言要抓住最核心的一条，就是日志从产生到到达最终目的地期间的处理流程 。

#### 3、Log4cpp

- 是记录日志的一种方式。

##### 3.1、log4cpp的查找

- 登录github，然后搜索awesome-cpp，然后来到fffaraz/awesome-cpp，接下来找到Logging，然后点进去找到log4cpp,在log4cpp的官网上，可以查看log4cpp的使用。

##### 3.2、log4cpp的安装

```C++
安装：先将log4cpp-1.1.1.tar.gz拖入用户主目录(~),
然后再执行以下步骤:
   
$ tar zxvf log4cpp-1.1.1.tar.gz 

$ cd ~/log4cpp/
$ ./configure
$ make
$ make check
$ sudo make install
    
    
默认lib库路径是 ： /usr/local/lib/
默认头文件的位置： /usr/local/include/log4cpp 
    
    
进入 $ sudo vim /etc/ld.so.conf，将log4cpp的库文件路径添加进去。
	include /etc/ld.so.conf.d/*.conf                                                       
	/usr/local/lib

//更新缓存
sudo ldconfig

//然后在/etc目录查看缓存的更新
wangdao@wangdao:log4cpp$ cd /etc/
wangdao@wangdao:etc$ ll *cache*
-rw-r--r-- 1 root root 80082 3月  28 11:36 ld.so.cache
wangdao@wangdao:etc$ date
2023年 03月 28日 星期二 11:36:22 CST
```

注意：C++17的版本与log4cpp是不兼容的，所以需要将C++17变成C++11/14

##### 3.3、阅读第三方库的方法

首先查看头文件include、实现文件src、测试文件test。可以通过test文件查看代码是怎么用的。

##### 3.4、log4cpp的使用

```C++
#include <iostream>
#include <log4cpp/SimpleLayout.hh>
#include <log4cpp/BasicLayout.hh>
#include <log4cpp/PatternLayout.hh>
#include <log4cpp/OstreamAppender.hh>
#include <log4cpp/FileAppender.hh>
#include <log4cpp/RollingFileAppender.hh>
#include <log4cpp/Category.hh>
#include <log4cpp/Priority.hh>

using std::cout;
using std::endl;
using namespace log4cpp;

void test()
{
    //1、日志的布局
    /* SimpleLayout *psl = new SimpleLayout(); */
    BasicLayout *pbl =  new BasicLayout();

    //2、日志的目的地
    OstreamAppender *pos = new OstreamAppender("ostream",&cout);
    /* pos->setLayout(psl); */
    pos->setLayout(pbl);

    //3、Catagory的种类,日志记录器
    Category &root = Category::getRoot();
    root.addAppender(pos);
    
    //当Category设置的优先级大于等于root调用的时候，书写的优先级
    //的时候，才能将这些日志记录下来
    //4、过滤器
    root.setPriority(Priority::ERROR);

    //记录日志
    root.fatal("this is an fatal message");
    root.alert("this is an alert message");
    root.crit("this is an crit message");
    root.error("this is an error message");
    root.warn("this is an warn message");
    root.info("this is an info message");
    root.debug("this is an debug message");

    //回收内存
    Category::shutdown();
}

void test2()
{
    //1、日志的布局
    PatternLayout *ppl1 = new PatternLayout();
    ppl1->setConversionPattern("%d %c [%p] %m%n");

    PatternLayout *ppl2 = new PatternLayout();
    ppl2->setConversionPattern("%d %c [%p] %m%n");

    //2、日志的目的地
    //注意：一个日志的目的地要对应一种日志的布局，不能共用
    //一旦共用就会发生错误
    //终端
    OstreamAppender *pos = new OstreamAppender("ostream", &cout);
    pos->setLayout(ppl1);

    //文件
    FileAppender *pfa = new FileAppender("FileAppender", "wd.txt");
    pfa->setLayout(ppl2);

    //3、Catagory的种类,日志记录器
    Category &root = Category::getRoot().getInstance("mycat");
    root.addAppender(pos);
    root.addAppender(pfa);
    
    //当Category设置的优先级大于等于root调用的时候，书写的优先级
    //的时候，才能将这些日志记录下来
    //4、过滤器
    root.setPriority(Priority::ERROR);

    //记录日志
    root.fatal("this is an fatal message");
    root.alert("this is an alert message");
    root.crit("this is an crit message");
    root.error("this is an error message");
    root.warn("this is an warn message");
    root.info("this is an info message");
    root.debug("this is an debug message");

    //回收内存
    Category::shutdown();
}

void test3()
{
    //1、日志的布局
    PatternLayout *ppl1 = new PatternLayout();
    ppl1->setConversionPattern("%d %c [%p] %m%n");

    PatternLayout *ppl2 = new PatternLayout();
    ppl2->setConversionPattern("%d %c [%p] %m%n");

    //2、日志的目的地
    //注意：一个日志的目的地要对应一种日志的布局，不能共用
    //一旦共用就会发生错误
    //终端
    OstreamAppender *pos = new OstreamAppender("ostream", &cout);
    pos->setLayout(ppl1);

    //回滚文件(卷积文件)
    RollingFileAppender *prfa = 
        new RollingFileAppender("RollingFileAppender"
                                , "wd.txt"
                                , 5*1024
                                , 3);
    prfa->setLayout(ppl2);

    //3、Catagory的种类,日志记录器
    Category &root = Category::getRoot().getInstance("mycat");
    root.addAppender(pos);
    root.addAppender(prfa);
    
    //当Category设置的优先级大于等于root调用的时候，书写的优先级
    //的时候，才能将这些日志记录下来
    //4、过滤器
    root.setPriority(Priority::ERROR);

    //记录日志
    size_t idx = 300;
    while(idx > 0)
    {
        root.fatal("this is an fatal message");
        root.alert("this is an alert message");
        root.crit("this is an crit message");
        root.error("this is an error message");
        root.warn("this is an warn message");
        root.info("this is an info message");
        root.debug("this is an debug message");
        --idx;
    }

    //回收内存
    Category::shutdown();
}
int main(int argc, char **argv)
{
    test3();
    return 0;
}
```

### 五、友元

#### 1、基本概念

面向对象四大基本特征：抽象、封装、继承、多态。

友元可以打破封装性的特点。

```C++
class 类名A
{
    friend 函数的原型;//可以是成员函数也可以是非成员函数
    friend class B;
};
```

函数：可以分为成员函数与非成员函数。

非成员函数：全局函数、自由函数、普通函数。

**重点：**

<img src="47期C++笔记.assets/image-20230328162517483.png" alt="image-20230328162517483" style="zoom:50%;" />

#### 2、友元的三种形式

##### 1、友元之普通函数的形式

```c++
  class Point{
  public:
      Point(int x, int y)
      :_ix(x),
      _iy(y)
      {
          cout << "Point Init" << endl;
      }
  
      ~Point(){
          cout << "Point Destroy" << endl;
      }
  
      //全局函数做友元
      friend float distance(const Point & lhs, const Point & rhs);
  
  private:
      int _ix;
      int _iy;
  };

  //全局函数做友元
  float distance(const Point & lhs, const Point & rhs){
      return hypot(lhs._ix - rhs._ix, lhs._iy - rhs._iy);
  }

  void test01(){
      Point p1(0,0);
      Point p2(3,4);
      cout << distance(p1, p2) << endl;
  }
```

##### 2、友元之成员函数

```c++
class Point;    //类的前向声明

class Line{
public:
    float distance(const Point & lhs, const Point & rhs);
//    Point pt; //field has incomplete type 'Point',point是不完整类型，不能创建对象
      /* Point * ppt;//不完整类型可以创建指针 */
};

class Point{
public:
    Point(int x, int y)
    :_ix(x),
    _iy(y)
    {
        cout << "Point Init" << endl;
    }

    ~Point(){
        cout << "Point Destroy" << endl;
    }
    
    //类函数做友元
    friend float Line::distance(const Point & lhs, const Point & rhs);

private:
    int _ix;
    int _iy;
};

//类函数做友元
float Line::distance(const Point & lhs, const Point & rhs){
    return hypot(lhs._ix - rhs._ix, lhs._iy - rhs._iy); 
}

void test01(){
    Point p1(0,0);
    Point p2(3,4);

    cout << "distance: " << Line().distance(p1, p2) << endl;	//直接创建临时对象，调用distance函数
}
```

##### 3、友元类

<img src="47期C++笔记.assets/image-20230328163714073.png" alt="image-20230328163714073" style="zoom:50%;" />

#### 3、友元的性质

- 友元关系是单向的。
- 友元关系没有传递性(A->B->C)。
- 友元不能被继承。
- 友元不受访问权限的控制。

### 六、运算符重载

- 原因：针对自定义类型而言，两个或者多个对象不能进行加减乘除，不能直接进行运算。

#### 1、形式

```c++
返回类型 operator 运算符(参数列表)
{
    //...
}
```

```C++
int x = a > b?a:b;
```

#### 2、规则

##### 2.1、不能重载的运算符有

- 成员访问运算符 `.`
- 成员指针运算符` .*`
- 三目运算符 `?:`
- 作用域限定符 `::`
- `sizeof`运算符

<img src="47期C++笔记.assets/image-20230328171832783.png" alt="image-20230328171832783" style="zoom:50%;" />

##### 2.2、几条规则

1、必须至少有一个类型是类类型或者枚举类型。（**重要**）

![image-20230328172302791](47期C++笔记.assets/image-20230328172302791.png)

2、运算符重载的时候，不能改变优先级与结合性。
3、运算符重载的时候，不能改变操作数的个数、不能改变操作数顺序，当然肯定不能设置默认值。
4、不能臆造不存在的运算符，例如：$、@
5、重载逻辑运算符(`&&,||`)后，不再具备短路求值特性  

#### 3、三种形式

1、运算符重载的第一种形式：运算符重载之普通函数的形式。（需要有get函数做支撑）

```c++
class Complex{
public:
    Complex(double real, double imag)
    :_real(real),
    _imag(imag)
    {
        cout << "Complex()" << endl;
    }

    void print(){
        cout << _real << " + " << _imag  << "i" << endl;
    }
    
    double getReal() const{
        return _real;
    }

    double getImag() const{
        return _imag;
    }
    
    ~Complex(){
        cout << "~Complex()" << endl;
    }
private:
    double _real;
    double _imag;
};

Complex operator+(const Complex &lhs, const Complex & rhs){
    cout << "Complex operator+(const Complex &lhs, const Complex & rhs)" << endl;
    return Complex(lhs.getReal() + rhs.getReal(), lhs.getImag() + rhs.getImag());
}

void test01(){
    Complex cmp1(1,2);
    cmp1.print();

    Complex cmp2(3,4);
    cmp2.print();

    Complex cmp3 = cmp1 + cmp2;
    cmp3.print();
}

```

<img src="47期C++笔记.assets/image-20230808214416970.png" alt="image-20230808214416970" style="zoom:90%;" />

2、运算符重载的第二种形式：成员函数的形式（形式上加号运算符少一个参数）

<img src="47期C++笔记.assets/image-20230328175001402.png" alt="image-20230328175001402" style="zoom:60%;" />

3、运算符重载的第三种形式：运算符重载之友元函数（推荐使用）

- 可以直接访问私有成员，函数参数个数明确，是第一种和第二种的结合体。

<img src="47期C++笔记.assets/image-20230328175424608.png" alt="image-20230328175424608" style="zoom:60%;" />

## C++Day09

### 一、问题回顾

1、文件输入流的特点？文件输出流的特点？文件输入输出流的特点？

2、文件对象（文件指针）的偏移？获取文件对象的位置（文件指针的位置）？

3、针对与文件输入流或者文件输出流的文件（追加）模式？

​	in,ate							out,app

4、串IO？

5、log4cpp的使用？

6、友元有哪三种形式？友元有什么性质？

7、哪些运算符不能重载？运算符重载的规则有哪些？

8、运算符重载的三种使用形式？

### 二、特殊运算符的重载

#### 1、复合赋值运算符的重载

<img src="47期C++笔记.assets/image-20230329100227512.png" alt="image-20230329100227512" style="zoom:50%;" />

#### 2、自增自减运算符的重载

<img src="47期C++笔记.assets/image-20230329102810536.png" alt="image-20230329102810536" style="zoom:50%;" />

#### 3、输入输出流运算符函数的重载

<img src="47期C++笔记.assets/image-20230329112309416.png" alt="image-20230329112309416" style="zoom:50%;" />

**注意：函数的参数中的引用符号（流的引用符号）与函数返回类型中的引用符号此处是不能去掉的，因为对于流而言，拷贝构造函数早就已经被删除了（不提供了）。**

<img src="47期C++笔记.assets/image-20230329112441626.png" alt="image-20230329112441626" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230329115245213.png" alt="image-20230329115245213" style="zoom:50%;" />

## C++Day10

### 一、特殊运算符的重载

#### 1、函数调用运算符的重载

- 将重载了函数调用运算符的类创建的对象称为函数对象

<img src="47期C++笔记.assets/image-20230330095124619.png" alt="image-20230330095124619" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230330095157668.png" alt="image-20230330095157668" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230330095144107.png" alt="image-20230330095144107" style="zoom:50%;" />

#### 2、下标访问运算符的重载

<img src="47期C++笔记.assets/image-20230330103220992.png" alt="image-20230330103220992" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230330103236969.png" alt="image-20230330103236969" style="zoom:50%;" />

#### 3、成员访问运算符的重载

<img src="47期C++笔记.assets/image-20230330112816774.png" alt="image-20230330112816774" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230330112704572.png" alt="image-20230330112704572" style="zoom:50%;" />

### 二、类型转换

#### 1、隐式转换

从其他类型向自定义类型进行转换，实质上发生的就是隐式转换，而隐式转换需要有自定义类型的构造函数做支撑。

<img src="47期C++笔记.assets/image-20230330113748603.png" alt="image-20230330113748603" style="zoom:50%;" />

#### 2、类型转换函数

```C++
operator 目标类型()
{
	 //...
}
```

<img src="47期C++笔记.assets/image-20230330115508483.png" alt="image-20230330115508483" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230330144318000.png" alt="image-20230330144318000" style="zoom:50%;" />

## C++Day11

### 一、问题回顾

1、什么是函数对象？

2、上课的例子中，对于下标访问运算的重载，为何返回类型要写为引用？

3、什么是隐式转换？需要什么做支撑？

4、类型转换函数的特点是什么？

### 二、类域

#### 1、作用域与可见域

<img src="47期C++笔记.assets/image-20230331095555078.png" alt="image-20230331095555078" style="zoom:50%;" />

#### 2、内部类

将一个类的定义放在另外一个类中。

##### 2.1、pimpl

<img src="47期C++笔记.assets/image-20230331104435110.png" alt="image-20230331104435110" style="zoom:50%;" />

##### 2.2、单例模式的自动释放

内存检测工具的安装

<img src="47期C++笔记.assets/image-20230331110409495.png" alt="image-20230331110409495" style="zoom:50%;" />

**检测的步骤**

1、编译程序，并且加上调试选项-g

```C++
g++ new.cc -o new -g
```

2、使用valgrind的命令

```C++
valgrind --tool=memcheck --leak-check=full  ./new    /*   ./new上一步的可执行程序  */
```

3、检查结果

<img src="47期C++笔记.assets/image-20230331111231365.png" alt="image-20230331111231365" style="zoom:67%;" />

<img src="47期C++笔记.assets/image-20230331111304240.png" alt="image-20230331111304240" style="zoom:50%;" />

###### 四种情况

- 1、友元的形式

```c++
class Signleton{
    friend class autoRelase;	//友元的形式
public:
    static Signleton * getInstance(){
        if(nullptr == _pInstence){
            _pInstence = new Signleton();
        }
        return _pInstence;
    }
private:
    Signleton(){
        cout << "Signleton()" << endl;
    }

    ~Signleton(){
        cout << "~Signleton()" << endl;
    }
static Signleton * _pInstence;
};

class autoRelase{
public:
    autoRelase(){
        cout << "autoRelase()" << endl;
    }

    ~autoRelase(){
        cout << "~autoRelase()" << endl;
        if(Signleton::_pInstence){
            delete Signleton::_pInstence;
            Signleton::_pInstence = nullptr;
        }
    }
};

Signleton * Signleton::_pInstence = nullptr;

void test01(){
    Signleton * ps1 = Signleton::getInstance(); 
    autoRelase ar;
}
```

- 2、内部类 + 静态数据成员(难点)

```c++
//内部类 + 静态数据成员
class Signleton{
public:
    static Signleton * getInstance(){
      /* autoRelase ar; */ //error,循环创建
        if(nullptr == _pInstence){
            _pInstence = new Signleton();
            /* autoRelase ar; */ //error，创建完立即就被销毁了，无用
        }
        return _pInstence;
    }
private:    //内部类一般都是作为私有
    class autoRelase{
    public:
        autoRelase(){
            cout << "autoRelase()" << endl;
        }

        ~autoRelase(){
            cout << "~autoRelase()" << endl;
            if(_pInstence){
                delete _pInstence;
                _pInstence = nullptr;
            }
        }
    };
private:
    Signleton(){
        cout << "Signleton()" << endl;
    }

    ~Signleton(){
        cout << "~Signleton()" << endl;
    }
    static Signleton * _pInstence;
    static autoRelase _ar;  //只能作为数据成员
};

Signleton * Signleton::_pInstence = nullptr;
Signleton::autoRelase Signleton::_ar;

void test01(){
    Signleton * ps1 = Signleton::getInstance(); 
    /* autoRelase ar;    //私有，访问不到 */
}
```

- 3、atexit + 饿汉模式

<img src="47期C++笔记.assets/image-20230331145333093.png" alt="image-20230331145333093" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230331145940156.png" alt="image-20230331145940156" style="zoom:50%;" />

- 4、pthread_once + atexit

<img src="47期C++笔记.assets/image-20230331152545964.png" alt="image-20230331152545964" style="zoom:50%;" />

### 三、写时复制

#### string的实现版本

1、深拷贝（浅拷贝）

2、写时复制：**浅拷贝 + 引用计数**。当进行读操作的时候，只是进行浅拷贝操作，并记录对象的个数；当进行写操作的时候，才去进行深拷贝。可以提高效率。（ubuntu1404版本使用的是写时复制）

<img src="47期C++笔记.assets/image-20230331161238811.png" alt="image-20230331161238811" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230331162047727.png" alt="image-20230331162047727" style="zoom:50%;" />

3、短字符串优化（sso）：当字符串的长度小于16字节的时候，申请在**栈上**；当字符串的长度大于等于16的时候，申请在**堆上**。(在ubuntu1804上使用短字符串优化sso)

```C++
&pInt = 0x7ffe026c8738
s1 =    0x7ffe026c8750
s2 =    0x7ffe026c8770
s3 = 0x556aaf3fae90
&pInt = 0x7ffe026c8738
pInt = 0x556aaf3fae70
s3 =   0x556aaf3fae90
```

#### 写时复制

引用计数存在与哪里？

用int的四个字节记录引用计数的大小。

<img src="47期C++笔记.assets/image-20230331165136173.png" alt="image-20230331165136173" style="zoom:50%;" />

## C++Day12

### 一、问题回顾

1、类的作用域分为哪几种？什么是内部类？

2、内部类的实现中，如何实现解耦？

​		pimpl

3、内存检测工具是什么？

4、单例模式的四种情况？

5、什么是写时复制？使用了什么技术？引用计数放在哪里？

浅拷贝 + 引用计数

6、短字符串优化有什么特点？

### 二、写时复制区分读写

之前的下标访问运算符没有管读与写的问题，现在需要重新考虑读与写。在我们代码中就是重新再重载赋值符号与输出流运算符。但是两个char不能重载，所以需要将String的下标访问运算符返回值设置为类类型即可，即：CharProxy。然后再在CharProxy中重载读与写，也就是输出流运算符与赋值符号。

## C++Day13

### 一、继承基本概念

#### 1、基本概念

面向对象的四大基本特征：抽象、封装、**继承**、多态。

继承在C++中的理解：从既有类产生新类的过程。

既有类：动物类。父类，基类

新类：鸟类。子类，派生类。

```C++
class 基类类名
{
public:
protetced:
private:
};

class 派生类类名 
: public/protected/private 基类类名 //派生类列表
{
public:
protetced:
private:   
};
```

#### 2、派生类生成的步骤（重点）

1、吸收基类的成员

2、改造基类的成员

3、新增自己的成员

总结：**吸收、改造、新增**。（重要）

#### 3、继承的局限

所有的数据成员是可以被派生类吸收、改造的，但是部分成员函数不行。

1、构造函数与析构函数不能被继承。

2、用户重载的operator new/delete/=

3、友元关系不能被继承

#### 4、不同继承方式的特点

<img src="47期C++笔记.assets/image-20230403103408847.png" alt="image-20230403103408847" style="zoom:50%;" />

#### 5、protected继承与private继承的区别

- proctected继承可以无限的继承下去，但是private继承一次就终止。（千秋万代，断子绝孙）

- **注意：如果不写继承方式，那么默认的继承方式都是私有的**。

### 二、派生类对象的构造与销毁

#### 1、几种情况

**重要：为了完成从基类吸收过来的数据成员的初始化，需要在派生类的构造函数的初始化列表中，借助基类的构造函数完成吸收过来的数据成员的初始化**。

```C++
派生类的构造函数名(参数列表) 
: 基类的构造函数(基类构造函数的参数列表)
{
    //派生类的构造函数的函数体
}
```

**1、基类没有定义构造函数，派生类有显示定义构造函数**

<img src="47期C++笔记.assets/image-20230403113344105.png" alt="image-20230403113344105" style="zoom:50%;" />

2、如果派生类没有显式定义构造函数而基类有显示定义构造函数，则基类必须拥有默认构造函数 ，因为派生类的构造函数会默认调用基类的默认（无参）构造函数。目的：就是为了完成吸收的数据成员的初始化。

总结：在创建派生类对象的时候，为了完成从基类吸收过来的数据成员的初始化，需要使用基类的构造函数，那么最好可以**手动在派生类的初始化列表中将基类的构造函数显示的调用出来**，这样可以保证代码不出错。

#### 2、派生类构造函数的调用顺序

1、完成对象所占内存的开辟
2、调用基类的构造函数，完成从基类吸收的数据成员的初始化
3、完成子对象、const数据成员、引用数据成员的初始化
4、执行派生类构造函数的函数体。

#### 3、派生类析构函数的调用顺序

派生类对象在销毁的时候（离开作用域的时候），会执行派生类自己的析构函数（完成派生类自己数据成员的清理操作）。然后，当派生类的析构函数执行完成之后，**基类的析构函数会被自动调用**。

1、先调用派生类的析构函数
2、再调用派生类中成员对象的析构函数
3、最后调用普通基类的析构函数  

### 三、多基派生（多继承）（难点）

#### 1、多继承的继承方式

<img src="47期C++笔记.assets/image-20230403150038034.png" alt="image-20230403150038034" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230403150550365.png" alt="image-20230403150550365" style="zoom:50%;" />

#### 2、成员函数访问冲突

<img src="47期C++笔记.assets/image-20230403151237956.png" alt="image-20230403151237956" style="zoom:50%;" />

#### 3、数据成员的二义性

解决方案：让B与C虚拟继承A（virtual）

<img src="47期C++笔记.assets/image-20230403153207323.png" alt="image-20230403153207323" style="zoom:50%;" />

### 四、关联式容器set的使用

<img src="47期C++笔记.assets/image-20230403172227777.png" alt="image-20230403172227777" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230403160256039.png" alt="image-20230403160256039" style="zoom:50%;" />

#### 1、set的初始化

<img src="47期C++笔记.assets/image-20230403162256004.png" alt="image-20230403162256004" style="zoom:50%;" />

#### 2、set的遍历

<img src="47期C++笔记.assets/image-20230403162321112.png" alt="image-20230403162321112" style="zoom:50%;" />

#### 3、查找

count与find函数的使用

<img src="47期C++笔记.assets/image-20230403162345663.png" alt="image-20230403162345663" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230403162903634.png" alt="image-20230403162903634" style="zoom:50%;" />

#### 4、set中元素的插入

<img src="47期C++笔记.assets/image-20230403163109374.png" alt="image-20230403163109374" style="zoom: 60%;" />

<img src="47期C++笔记.assets/image-20230403164748066.png" alt="image-20230403164748066" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230403164821701.png" alt="image-20230403164821701" style="zoom:50%;" />

- set中不支持下标访问，也不知道修改操作。

### 五、关联式容器map的使用

<img src="47期C++笔记.assets/image-20230403175824711.png" alt="image-20230403175824711" style="zoom:50%;" />

#### 1、初始化

<img src="47期C++笔记.assets/image-20230403173407450.png" alt="image-20230403173407450" style="zoom:50%;" />

#### 2、遍历

<img src="47期C++笔记.assets/image-20230403173426463.png" alt="image-20230403173426463" style="zoom:50%;" />

#### 3、查找

<img src="47期C++笔记.assets/image-20230403173737647.png" alt="image-20230403173737647" style="zoom:50%;" />

#### 4、map的插入

<img src="47期C++笔记.assets/image-20230403173926586.png" alt="image-20230403173926586" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230403174618196.png" alt="image-20230403174618196" style="zoom:50%;" />

#### 5、下标操作（重点）

下标中传递的类型是key的类型，而不是传统的数字0,1,2

<img src="47期C++笔记.assets/image-20230403175051388.png" alt="image-20230403175051388" style="zoom:50%;" />

## C++Day14

### 一、问题回顾

1、派生类生成的步骤是什么？

吸收、修改、新增。

2、不同继承方式的特点是什么？

3、创建派生类对象需要注意什么？（重要）

**要完成从基类吸收过来的数据成员的初始化**。

4、派生类构造函数与析构函数的调用顺序？

5、多基继承中的两个问题是什么？如何解决这两个问题？



### 二、基类与派生类间的相互转换

**类型适应，派生类对象是可以适用于基类对象的**。（**重要**）

<img src="47期C++笔记.assets/image-20230404102751479.png" alt="image-20230404102751479" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230404102834885.png" alt="image-20230404102834885" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230404102904408.png" alt="image-20230404102904408" style="zoom:50%;" />



向上转型：从派生类向基类进行转换，都是可以的。
向下转型：从基类向派生类进行转换，本来语法是不支持的，但是C++支持强转，所以又支持了。但是向下转型存在不安全性。（有安全的，也有不安全的向下转型）

<img src="47期C++笔记.assets/image-20230404110106027.png" alt="image-20230404110106027" style="zoom:50%;" />



### 三、派生类对象间的赋值控制

1、如果派生类没有显示定义拷贝构造函数或者赋值运算符函数，但是基类定义类拷贝构造函数与赋值运算符函数，那么用一个已经存在的派生类对象初始化一个刚刚创建的派生类对象，或者用一个已经存在的派生类对象给另外一个已经存在的派生类对象进行赋值，那么两个派生类部分执行**缺省的行为**，而两个基类部分执行基类的拷贝构造函数或者赋值运算符函数。

2、如果派生类**显示定义拷贝构造函数或者赋值运算符函数**，基类也定义类拷贝构造函数与赋值运算符函数，那么用一个已经存在的派生类对象初始化一个刚刚创建的派生类对象，或者用一个已经存在的派生类对象给另外一个已经存在的派生类对象进行赋值，那么两个派生类部分执行派生类的拷贝构造函数或者派生类的赋值运算符函数，而两个基类部分就**不会再自动**执行基类的拷贝构造函数或者赋值运算符函数，除非在派生类的拷贝构造函数或者赋值运算符函数中**显示执行**基类的拷贝构造函数或者赋值运算符函数。

<img src="47期C++笔记.assets/image-20230404114736733.png" alt="image-20230404114736733" style="zoom:53%;" /><img src="47期C++笔记.assets/image-20230404114720246.png" alt="image-20230404114720246" style="zoom:50%;" />

### 四、禁止复制

<img src="47期C++笔记.assets/image-20230404144221410.png" alt="image-20230404144221410" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230404144242691.png" alt="image-20230404144242691" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230404144300920.png" alt="image-20230404144300920" style="zoom:50%;" />

### 五、多态

#### 1、基本概念

多态：对于**同一种指令**（警车鸣笛），针对**不同的对象**（普通人、警察、嫌疑犯），产生**不一样的行为**（正常行为、抓捕、藏起来）。

#### 2、分类

静态多态：函数重载、运算符重载、模板都是属于静态多态。**发生的时机在编译的时候**。

动态多态：**发生的时机在运行的时候**。使用**虚函数**进行体现。

### 六、虚函数

#### 1、定义

在**成员函数**的前面加上**virtual**关键字的函数，称为虚函数。

#### 2、重定义（重写）要求

- 基类与派生类中函数名字要相同
- 函数的参数列表也要相同（包括参数的个数、参数的类型、参数的顺序）
- 函数的返回类型也要一致

总结：基类与派生类中的同名虚函数，除了**函数体可以不一样之外**，其他的全部都要保持一致。（函数的名字、函数的返回类型、函数的参数列表（参数个数、参数顺序、参数类型））

#### 3、虚函数的原理（重要）

<img src="47期C++笔记.assets/image-20230404161211656.png" alt="image-20230404161211656" style="zoom:45%;" /><img src="47期C++笔记.assets/image-20230404161735590.png" alt="image-20230404161735590" style="zoom:50%;" />

#### 4、动态多态被激活的五个条件（重要）

1、基类要定义虚函数
2、派生类要重写（重定义、覆盖）该虚函数
3、创建派生类的对象
4、基类的指针指向（引用绑定）派生类的对象
5、基类的指针（引用）调用虚函数

#### 5、哪些函数不能被设置为虚函数

1、普通函数：因为虚函数必须是成员函数，而普通函数是非成员函数，所以就不能被设置为虚函数。

2、静态成员函数：静态成员函数发生的时机在编译的时候，而虚函数要体现多态，必须在运行的时候；静态成员函数没有this指针，是被该类的所有对象共享的，就是唯一的。

3、内联函数：内联成员函数发生的时机在编译的时候，而虚函数要体现多态，必须在运行的时候；内联如果写成虚函数，那么就是去了内联的函数。

4、友元函数：如果友元函数本身是一个普通函数，那么友元函数不能被设置为虚函数；但是如果友元函数本身是成员函数，那么该友元函数是可以被设置为虚函数的。

5、构造函数：构造函数发生的时机在编译的时候，而虚函数要体现多态，必须在运行的时候；构造函数是不可以被继承的，而虚函数是可以被继承的；如果将构造函数设置为虚函数，那么就需要通过虚表找到虚函数的入口地址，那么就需要虚函数指针指向虚表，而虚函数指针存在对象布局的最前面，而如果构造函数不调用，那么对象就不一定是完整的，那么对象的存储布局的前面就不一定有虚函数指针，那如果没有虚函数指针就不能指向虚表。

### 七、虚函数的访问

#### 1、使用指针进行访问

可以体现动态多态。

#### 2、使用引用进行访问

可以体现动态多态。

#### 3、使用对象进行访问

虚函数体现的就是普通成员函数的特性，在编译的时候就已经确定了函数调用。

#### 4、使用其他普通成员函数调用

<img src="47期C++笔记.assets/image-20230404174630977.png" alt="image-20230404174630977" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230404174708748.png" alt="image-20230404174708748" style="zoom:50%;" />

#### 5、使用特殊成员函数进行访问

在调用Father的构造函数的时候，调用func1()时候，派生类Son的对象还没有构建完成，所以就看不到虚表这套逻辑，所以只能看到的func1()就是Father自己的。而当派生了Son销毁的时候，虚表都己经销毁了，所以再调用Father的func2()的时候，已经看不到Son的这套逻辑，所以就只会调用到Father自己的func2函数。所以都没有体现动态多态。

## C++Day15

### 一、问题回顾

1、什么是类型适应？派生类对象可以向基类对象转换吗？基类对象可以向派生类对象转换吗？

2、如何实现禁止复制？有哪三种形式？

3、什么是多态？可以分为哪些类型？有什么区别？

4、什么是虚函数？重写有什么严格要求？

5、虚函数的原理是什么？动态多态被激活有哪五个条件？

6、为何构造函数不能被设置为虚函数？

7、虚函数被访问有哪几种形式？哪些体现了多态？

### 二、抽象类

Q:动态多态与虚函数是不是等价的？

A:动态多态的体现需要虚函数；但是有虚函数并不一定能体现动态多态。

#### 1、纯虚函数

<img src="47期C++笔记.assets/image-20230405103108371.png" alt="image-20230405103108371" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230405103144177.png" alt="image-20230405103144177" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230405103207525.png" alt="image-20230405103207525" style="zoom:50%;" />

#### 2、抽象类的第二种形式（了解）

<img src="47期C++笔记.assets/image-20230405110934230.png" alt="image-20230405110934230" style="zoom:50%;" />

### 三、虚析构函数(重要)

为了解决内存泄漏的问题，所以需要将析构函数设置为虚函数。

<img src="47期C++笔记.assets/image-20230405113616874.png" alt="image-20230405113616874" style="zoom:50%;" />

总结：以后可以将所有的只要有多态产生的情况，都可以将基类的析构函数设置为虚函数，这样可以保证所有的派生类中的析构函数自动被设置为虚函数，可以避免内存泄漏的产生。

<img src="47期C++笔记.assets/image-20230405114615360.png" alt="image-20230405114615360" style="zoom:50%;" />

## C++Day16

### 一、问题回顾

1、抽象类有哪两种形式？

2、为何可以将析构函数设置为虚函数？

### 二、重载、重定义、隐藏（重要）

**重载**：在**同一个作用域**中，函数名字相同，函数的参数列表不一样（参数的个数、参数的类型、参数的顺序），注意：没有考虑返回类型。

**重定义（重写、覆盖）**：发生在基类与派生类中，同名的**虚函数**，并且参数列表也要一样，返回类型也要一样。

**隐藏**：发生在基类与派生类中，派生类中的函数与基类中的**函数名字相同**。派生类的数据成员也可以隐藏基类中的同名数据成员。（总结：可能发生的是数据成员，也可能是成员函数）

<img src="47期C++笔记.assets/image-20230406100413629.png" alt="image-20230406100413629" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230406100500356.png" alt="image-20230406100500356" style="zoom:50%;" />

### 三、虚表的存在

<img src="47期C++笔记.assets/image-20230406111614290.png" alt="image-20230406111614290" style="zoom:50%;" />

```C++
对象derived的地址: 0x7ffc1a2a2ba0
对象derived的地址: 0x7ffc1a2a2ba0
虚表的地址: 0x55949e9e4d00
虚表的地址: 0x55949e9e4d00
第一个虚函数的地址:  0x55949e7e40dc
第一个虚函数的地址 : 0x55949e7e40dc
第一个虚函数的地址:  0x55949e7e40dc
void Derived::func()

第二个虚函数的地址 : 0x55949e7e4114
void Derived::gunc()

第三个虚函数的地址 : 0x55949e7e414c
void Derived::hunc()

Base(long = 0)
Derived(long = 0, long  = 0)
对象derived2的地址: 0x7ffc1a2a2bc0
对象derived2的地址: 0x7ffc1a2a2bc0
虚表的地址: 0x55949e9e4d00
第一个虚函数的地址: 0x55949e7e40dc
~Derived()
~Base()
~Derived()
~Base()

```

<img src="47期C++笔记.assets/image-20230406111505215.png" alt="image-20230406111505215" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230406111527758.png" alt="image-20230406111527758" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230406111918211.png" alt="image-20230406111918211" style="zoom:50%;" />

### 四、带虚函数多基派生（重要）

<img src="47期C++笔记.assets/image-20230406142957982.png" alt="image-20230406142957982" style="zoom:50%;" />

如何判断一个函数是虚函数还是非虚函数？

就利用动态多态被激活的五个条件，在基类中实现这个函数，在派生类也实现这个函数，然后创建派生类对象，在构建基类的指针指向派生类对象，再使用基类的指针调用该函数，如果调用的结果显示是基类中的函数体，那么该函数就是非虚函数，否则就是虚函数。

<img src="47期C++笔记.assets/image-20230406144142983.png" alt="image-20230406144142983" style="zoom:50%;" />

### 五、内存布局（重点，难点）

PPT中，txt文档中都有解释，自己再研究研究。

### 六、虚拟继承

虚函数与虚拟继承中的虚的含义，存在、间接、共享。

```C++
class Derived
: virtual public/protected/private Base   //ok
//:  public/protected/private virtual Base  //ok
 {
     
 };
```

<img src="47期C++笔记.assets/image-20230406172139305.png" alt="image-20230406172139305" style="zoom:50%;" />

为了防止虚基类A中的数据被初始化多次，所以最终的派生类需要进行完成虚基类A中数据成员的初始化。

### 七、效率分析（了解）

虚函数不一定能提升程序的效率，但是可以让程序变得更加灵活。比如：可以使用基类的指针调用到派生类函数。

灵活性与效率之间做平衡。

### 八、如何使用第三方库代码

#### 1、直接百度

在公司中完成任务是ok的。

#### 2、研究代码

第一步：查看第三方代码的头文件include、实现文件src、测试文件test

第二步：找到测试文件中的main函数。如果程序能编译运行最好的，可以生成可执行文件，使用gdb一步步的运行程序，在运行的过程中需要画出类图、类与类之间的关系、找到重要经常出现的函数。

第三步：可以做相应的文字比较。

## C++Day17

### 一、问题回顾

1、什么是重载、重定义、重写、隐藏？

2、内存布局形式？

普通继承，会先存基类的逻辑（虚函数指针、数据成员），再存派生类的逻辑（数据成员）。

**虚拟继承**，先存派生类的逻辑（虚基指针，数据成员），再存基类的逻辑（虚函数指针、数据成员）。需要注意的是，派生类有没有新增虚函数，那么就会在派生类对象的存储布局的前面多一个虚函数指针用来指向新的虚表。

多继承可以看成是多个单继承的组合。

菱形继承，会存在存储二义性。

3、虚拟继承的特点？

### 二、左值右值

左值：可以进行取地址的就是左值。
右值：不能进行取地址的就是右值。右值包括：临时变量、临时对象、匿名变量、匿名对象、字面值常量（10）

左值引用：int &ref;左值引用可以绑定到左值，不能绑定到右值。可以识别左值。
const左值引用：既可以绑定到左值，也可以绑定到右值，所以，const左值引用不能区分出左值与右值。
右值引用：int &&rref;右值引用可以绑定到右值，但是不能绑定到左值。可以识别右值。

右值引用的特点是：可以识别右值，可以绑定到右值。但是右值引用本身既可以是左值，也可以是右值。比如：当我们将右值引用作为函数参数的时候，在移动构造函数与移动赋值函数中就是**左值**，但是如果将函数的返回类型设置为右值引用的时候，那么右值引用本身就是一个**右值**了。

<img src="47期C++笔记.assets/image-20230407151409361.png" alt="image-20230407151409361" style="zoom:50%;" />

### 三、移动构造函数（重要）

将拷贝构造函数以及赋值运算符函数称为具有复制控制语义的函数。
将移动构造函数以及移动赋值运算符函数称为具有移动语义的函数。

1、移动语义的函数优先于具有拷贝语义的函数的执行
2、具有移动语义的函数如果不写的话，编译器是不会自动生成，必须手写

<img src="47期C++笔记.assets/image-20230407145137540.png" alt="image-20230407145137540" style="zoom:50%;" />

### 四、移动赋值运算符函数（重要）

<img src="47期C++笔记.assets/image-20230407150451740.png" alt="image-20230407150451740" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230407150744751.png" alt="image-20230407150744751" style="zoom:50%;" />

### 五、RAII的思想

利用栈对象的生命周期管理资源（内存资源、文件描述符、文件、锁）。

#### 四个基本特征

1、在构造函数中初始化资源，或者称为托管资源
2、在析构函数中释放资源
3、提供若干访问资源的方法（比如：读写文件）
4、一般不允许复制或者赋值。（对象语义）

**对象语义**：不允许复制或者赋值。

- 1、将拷贝构造函数或者赋值运算符函数=delete
- 2、将拷贝构造函数或者赋值运算符函数设置为私有的
- 3、可以使用继承的思想，将基类拷贝构造函数与赋值运算符函数删除（设为私有），让派生类继承基类

**值语义**：可以进行复制或者赋值。

<img src="47期C++笔记.assets/image-20230407171146434.png" alt="image-20230407171146434" style="zoom:67%;" />

### 六、智能指针

#### 1、auto_ptr的使用

```C++
class auto_ptr
{
public:
    auto_ptr(_Tp* __p = 0)  
    : _M_ptr(__p) 
    {
        
    } 
    
    //auto_ptr<int> ap2(ap);
    //auto_ptr& __a = ap
	auto_ptr(auto_ptr& __a)  
	: _M_ptr(__a.release()) 
	{

	}
    
    //auto_ptr& __a = ap
    _Tp* release() 
    {
        _Tp* __tmp = _M_ptr;
        _M_ptr = nullptr;
        return __tmp;
    }
 private:
     _Tp* _M_ptr;
};
```

<img src="47期C++笔记.assets/image-20230407165106064.png" alt="image-20230407165106064" style="zoom:50%;" />

#### 2、unique_ptr的使用

##### 不允许复制或者赋值。

<img src="47期C++笔记.assets/image-20230407172850498.png" alt="image-20230407172850498" style="zoom:50%;" />

##### 具有移动语义，可以作为容器的元素（容器中可以存unique_ptr的类型）

<img src="47期C++笔记.assets/image-20230407173021600.png" alt="image-20230407173021600" style="zoom:50%;" />

#### 3、shared_ptr的使用

是一个共享所有权的智能指针，允许对象之间进行复制或者赋值，展示出来的就是值语义。使用**引用计数**的观点。当对象之间进行复制或者赋值的时候，引用计数会加+1，当最后一个对象销毁的时候，引用计数减为0的时候，会负责回收托管的空间。

<img src="47期C++笔记.assets/image-20230407174358982.png" alt="image-20230407174358982" style="zoom:60%;" />

##### 问题：存在循环引用？

会出现内存泄漏。

<img src="47期C++笔记.assets/image-20230407180052902.png" alt="image-20230407180052902" style="zoom:60%;" />

## C++Day18

### 一、问题回顾

1、什么是左值、右值、左值引用、const左值引用？

2、移动构造函数的形态？移动赋值运算符函数的形态？四个步骤？

3、RAII的思想是什么？有哪四个特征？

4、auto_ptr的缺点是什么？

5、unique_ptr有什么特征？

6、shared_ptr有什么特征？

### 二、智能指针

#### 1、shared_ptr的使用

循环引用导致的原因是shared_ptr是强引用的智能指针，每一次指向都会使得引用计数进行累加。但是单独的靠智能指针这种栈对象的销毁又不能将引用计数减为0，所以就会出现循环引用而不能完成空间回收的问题。就需要有一种弱引用的智能指针，可以执行空间，但是不会将引用计数累加，就需要让shared_ptr与weak_ptr结合使用。

#### 2、weak_ptr的使用

称为弱引用的智能指针，不会将引用计数进行累加。

```C++
bool expired() const;
//如果引用计数use_count()==0,那么该函数的返回值就是true；如果use_count() != 0,那么该函数的返回值就是false
```

```C++
std::shared_ptr<T> lock() const;
//将weak_ptr提升为一个share_ptr，然后再来判断shared_ptr，进而知道weak_ptr指向的空间还在还是不在。
```

<img src="47期C++笔记.assets/image-20230408102703404.png" alt="image-20230408102703404" style="zoom: 50%;" />

### 三、删除器

```C++
template<
    class T,
    class Deleter = std::default_delete<T>
> class unique_ptr;
```

```C++
template< class Y, class Deleter >
shared_ptr( Y* ptr, Deleter d );
```

对于unique_ptr而言，删除器在模板参数中，但是对于shared_ptr而言，删除器在构造函数中。

<img src="47期C++笔记.assets/image-20230408111151911.png" alt="image-20230408111151911" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230408112034798.png" alt="image-20230408112034798" style="zoom:50%;" />

### 四、智能指针的误用

使用了不同的智能指针托管同一块堆空间（同一个裸指针）

​						<img src="47期C++笔记.assets/image-20230408115718488.png" alt="image-20230408115718488" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230408115735078.png" alt="image-20230408115735078" style="zoom:50%;" />

​													<img src="47期C++笔记.assets/image-20230408115822941.png" alt="image-20230408115822941" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230408120749369.png" alt="image-20230408120749369" style="zoom:50%;" />

## C++Day19

### 一、问题回顾

1、循环引用会产生什么问题？如何解决循环引用？

2、为何要定义删除器？哪两个智能指针存在删除器？它们的区分是什么？

3、智能指针的误用包括哪些情况？

### 二、模板

泛型编程

#### 定义

```C++
template <typename T1，typename T2> //模板参数列表
template <class T> //模板参数列表
//在模板参数列表中，class与typename的含义是完全一样。

void func(int x, int y)
```

#### 分类

函数模板、类模板

### 三、函数模板

#### 1、基本概念

```C++
int add(int x, int y);
double add(double x, double y);
string add(string x, string y);

template <typename T>//模板参数
T add(T x, T y)
```

<img src="47期C++笔记.assets/image-20230410101350500.png" alt="image-20230410101350500" style="zoom:50%;" />

#### 2、实例化

显示实例化（可以人为写出类型，不用靠编译器推导）与隐式实例化（靠编译器自动推导）

<img src="47期C++笔记.assets/image-20230410101535725.png" alt="image-20230410101535725" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230410102712875.png" alt="image-20230410102712875" style="zoom:45%;" />

#### 3、头文件与实现文件

<img src="47期C++笔记.assets/image-20230410103724064.png" alt="image-20230410103724064" style="zoom:50%;" />

#### 4、特化

<img src="47期C++笔记.assets/image-20230410110910449.png" alt="image-20230410110910449" style="zoom:60%;" />

**注意：函数模板是支持全特化的，但是不同的编译器，不同的语法版本，可能不支持偏特化，不支持部分特化。**

#### 5、模板参数类型

包括类型参数与非类型参数。

<img src="47期C++笔记.assets/image-20230410112659927.png" alt="image-20230410112659927" style="zoom: 50%;" />

#### 6、成员函数模板

<img src="47期C++笔记.assets/image-20230410113745384.png" alt="image-20230410113745384" style="zoom:50%;" />

### 四、可变模板参数

可以表示0个到任意个参数，参数的个数不确定，参数的类型也不确定。可以类比printf进行理解。

<img src="47期C++笔记.assets/image-20230410144427638.png" alt="image-20230410144427638" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230410144543973.png" alt="image-20230410144543973" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230410145358976.png" alt="image-20230410145358976" style="zoom:50%;" />

### 五、类模板

```C++
template <typename T>
class Stack
{
private:
    T *_data;
    //int *_data;
    //double *_data;
    //Point *_data;
};
```

注意：**成员模版不能声明为虚函数**。写成模板相当于写了好多个函数，如果再将这些函数设计为虚函数，而虚函数会入虚表，那么都不知道模板可以推导出多少个函数，那么虚表就不知道分配多少空间。

模板是可以进行嵌套的。

```C++
#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

//泛型编程
template <typename T = int, size_t sz = 10>
class Stack
{
public:
    Stack()
    : _top(-1)
    , _data(new T[sz]())
    {

    }
    ~Stack();
    bool empty() const;
    bool full() const;
    void push(const T &value);
    void pop();
    T top() const;
private:
    int _top;
    T *_data;
};

template <typename T, size_t sz>
Stack<T, sz>::~Stack()
{
    if(_data)
    {
        delete [] _data;
        _data = nullptr;
    }
}

template <typename T, size_t sz>
bool Stack<T, sz>::empty() const
{
    return -1 == _top;
}

template <typename T, size_t sz>
bool Stack<T, sz>::full() const
{
    return _top == sz - 1;
}

template <typename T, size_t sz>
void Stack<T, sz>::push(const T &value)
{
    if(!full())
    {
        _data[++_top] = value;
    }
    else
    {
        cout << "The stack is full, cannot push any data" << endl;
        return;
    }
}

template <typename T, size_t sz>
void Stack<T, sz>::pop()
{
    if(!empty())
    {
        --_top;
    }
    else
    {
        cout << "The stack is empty, cannot pop any data" << endl;
        return;
    }
}

template <typename T, size_t sz>
T Stack<T, sz>::top() const
{
    return _data[_top];
}

void test()
{
    Stack<int> st;
    cout << "栈是不是空的 ?" << st.empty() << endl;
    st.push(1);
    cout << "栈是不是满的 ?" << st.full() << endl;

    for(size_t idx = 2; idx != 15; ++idx)
    {
        st.push(idx);
    }
    cout << "栈是不是满的 ?" << st.full() << endl;

    while(!st.empty())
    {
        cout << st.top() << "  ";
        st.pop();
    }
    cout << endl;
    cout << "栈是不是空的 ?" << st.empty() << endl;
}

void test2()
{
    Stack<string, 20> st;

    cout << "栈是不是空的 ?" << st.empty() << endl;
    st.push(string("aa"));
    cout << "栈是不是满的 ?" << st.full() << endl;

    for(size_t idx = 1; idx != 15; ++idx)
    {
        st.push(string(2, 'a' + idx));
    }
    cout << "栈是不是满的 ?" << st.full() << endl;

    while(!st.empty())
    {
        cout << st.top() << "  ";
        st.pop();
    }
    cout << endl;
    cout << "栈是不是空的 ?" << st.empty() << endl;
}

int main(int argc, char **argv)
{
    test2();
    return 0;
}
```

## C++Day20

### 一、问题回顾

1、什么是泛型编程（通用编程）的思想？

2、什么是实例化？什么是模板的特化与偏特化？模板的参数有哪些类型？

3、模板能不能分成头文件与实现文件？

4、可变模板参数的基本写法是怎么样的？什么是模板参数包？什么是函数参数包？什么是打包与解包？

5、类模板的写法？成员函数模板能不能写成虚函数？



### 二、STL概述

标准模板库（STL），有六大组件

1、容器（数据结构）：用来存数据的。

- 序列式容器   vector、list
- 关联式容器  set、map
- 无序关联式容器  unordered_set、unordered_map

2、迭代器：看成是一种指针，称为泛型指针。

3、算法：可以对容器中的数据进行相应的操作。

4、适配器

- 容器适配器 优先级队列
- 算法适配器   
- 迭代器的适配器  （源码）

5、函数对象（仿函数）：做定制化操作。

6、空间配置器（allocator）：空间的申请与释放。（研究基本使用 + 原理 + 源码）

程序 = 容器（数据结构） + 算法



### 三、序列式容器

<img src="47期C++笔记.assets/image-20230411101625040.png" alt="image-20230411101625040" style="zoom:67%;" />

#### 1、初始化（掌握）

三种序列式容器vector、deque、list完全支持五种初始化的方式

<img src="47期C++笔记.assets/image-20230411102218729.png" alt="image-20230411102218729" style="zoom:55%;" />

#### 2、遍历（掌握）

三种序列式容器，其中：list是没有下标的，所以不支持下标访问运算符。其他的三种遍历的方式，三种容器都支持。

​							<img src="47期C++笔记.assets/image-20230411102238727.png" alt="image-20230411102238727" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230411102257989.png" alt="image-20230411102257989" style="zoom:50%;" />

注意：list不支持下标

![image-20230411103201698](47期C++笔记.assets/image-20230411103201698.png)

#### 3、在尾部进行插入与删除

三种容器在尾部进行插入与删除的使用是完全一样的。

<img src="47期C++笔记.assets/image-20230411110354971.png" alt="image-20230411110354971" style="zoom:50%;" />

#### 4、在头部进行插入与删除

deque与list支持在头部进行插入与删除，但是vector没有在头部进行插入与删除的操作。

<img src="47期C++笔记.assets/image-20230411111015025.png" alt="image-20230411111015025" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230411111637761.png" alt="image-20230411111637761" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230411111705792.png" alt="image-20230411111705792" style="zoom:67%;" />

#### 5、vector的原理图

<img src="47期C++笔记.assets/image-20230411112336003.png" alt="image-20230411112336003" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230411113445729.png" alt="image-20230411113445729" style="zoom: 50%;" />

<img src="47期C++笔记.assets/image-20230411113946511.png" alt="image-20230411113946511" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230411114922156.png" alt="image-20230411114922156" style="zoom:50%;" /> 

_Tp*     _M_start，指向第一个元素； _M_finish，指向最后一个元素的下一个位置； _M_end_of_storage最后一个空间的下一个位置

```C++
template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >
class vector
{
public:
    //类型萃取（重要）
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    
    //为了严格表明_Base::allocator_type是一种类型，所以加上typename关键字进行强调
    typedef typename _Base::allocator_type allocator_type;
    
    //vector的下标访问运算符的重载
    reference operator[](size_type __n)
    { 
        return *(begin() + __n); 
    }
    
    void _M_range_check(size_type __n) const 
    {
       if (__n >= this->size())
           __stl_throw_range_error("vector");
    }

    //总结：通过随机获取元素，可以使用at，也可以直接使用下标，但是at比下标访问更安全，因为有范围检查
    reference at(size_type __n)
    {
		_M_range_check(__n); 
		return (*this)[__n]; 
    }
};
```

<img src="47期C++笔记.assets/image-20230411143333103.png" alt="image-20230411143333103" style="zoom:67%;" />

```C++
vector<int>::iterator it;
deque<int>::iterator it;
list<int>::iterator it;
```

<img src="47期C++笔记.assets/image-20230411145233023.png" alt="image-20230411145233023" style="zoom:50%;" />

#### 6、deque的原理图

<img src="47期C++笔记.assets/image-20230411151218498.png" alt="image-20230411151218498" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230411151745129.png" alt="image-20230411151745129" style="zoom:50%;" />

注意：deque是由很多小片段组成的，片段内部是连续的，片段之间是不连续。所以可以这么说，逻辑上是连续的，但是物理上是不连续。可以通过**中控器数组**进行调控。

#### 7、在任意位置进行插入（掌握）

三种序列式容器在任意位置插入元素的**四种方法**

<img src="47期C++笔记.assets/image-20230411155439220.png" alt="image-20230411155439220" style="zoom:60%;" />

<img src="47期C++笔记.assets/image-20230411160223646.png" alt="image-20230411160223646" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230411160325487.png" alt="image-20230411160325487" style="zoom:60%;" />

总结：对于list而言，插入的时候，迭代器是跟着**结点走了**，它在使用的时候，不会存在什么问题。但是对于vector而言，插入元素的大小会影响vector底层的扩容，有可能会导致**迭代器失效**。所以为了解决这个问题，每次操作迭代器时候，最好可以提前更新迭代器的位置，让迭代器指向新的空间的位置，这样就保证不会出错。

特意的，对于deque而言，去进行insert操作的时候，也有可能**迭代器失效**，所以最好还是可以每次使用迭代器的时候，像vector一样，将迭代器的位置进行更新，指向新的空间的位置。

#### 8、vector删除连续重复元素

<img src="47期C++笔记.assets/image-20230411171636257.png" alt="image-20230411171636257" style="zoom:60%;" />

#### 9、元素的清空

<img src="47期C++笔记.assets/image-20230411172728324.png" alt="image-20230411172728324" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230411172941418.png" alt="image-20230411172941418" style="zoom:55%;" /><img src="47期C++笔记.assets/image-20230411173211860.png" alt="image-20230411173211860" style="zoom:55%;" />

#### 10、emplace_back的使用

<img src="47期C++笔记.assets/image-20230411174050862.png" alt="image-20230411174050862" style="zoom:67%;" />

## C++Day21

### 一、问题问题

1、STL的六大组件是什么？

2、序列式容器的初始化有哪五种？遍历方式有哪几种？

3、vector的原理图？deque的原理图？

4、序列式容器的insert操作？迭代器失效？

5、vector的erase操作？

### 二、序列式容器

#### 1、list的特殊用法

##### sort函数（重点）

<img src="47期C++笔记.assets/image-20230412100334435.png" alt="image-20230412100334435" style="zoom:60%;" />

<img src="47期C++笔记.assets/image-20230412100435735.png" alt="image-20230412100435735" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230412100953228.png" alt="image-20230412100953228" style="zoom:55%;" />



##### merge操作（重要）

<img src="47期C++笔记.assets/image-20230412101730595.png" alt="image-20230412101730595" style="zoom:50%;" />

##### splice操作（重要）

<img src="47期C++笔记.assets/image-20230412102140805.png" alt="image-20230412102140805" style="zoom:55%;" /><img src="47期C++笔记.assets/image-20230412104025064.png" alt="image-20230412104025064" style="zoom:55%;" />

<img src="47期C++笔记.assets/image-20230412104142819.png" alt="image-20230412104142819" style="zoom:50%;" />

#### 2、vector的insert插入扩容（了解）

<img src="47期C++笔记.assets/image-20230412111212085.png" alt="image-20230412111212085" style="zoom:50%;" />

### 三、关联式容器

#### set的使用

<img src="47期C++笔记.assets/image-20230412113832847.png" alt="image-20230412113832847" style="zoom:67%;" />

注意：set是不支持下标访问的，set也不支持修改操作。

<img src="47期C++笔记.assets/image-20230412115638515.png" alt="image-20230412115638515" style="zoom:50%;" />

## C++Day22

### 一、问题回顾

1、list的特殊操作？sort、merge、splice

### 二、关联式容器

#### 1、set的使用

针对于自定义类型的三种形式（重要）

##### 1、模板的特化

<img src="47期C++笔记.assets/image-20230413095450713.png" alt="image-20230413095450713" style="zoom:50%;" />

##### 2、函数对象的形式

<img src="47期C++笔记.assets/image-20230413095523639.png" alt="image-20230413095523639" style="zoom:50%;" />

##### 3、运算符重载形式

<img src="47期C++笔记.assets/image-20230413095606167.png" alt="image-20230413095606167" style="zoom:50%;" />

#### 2、multiset的使用

##### 基本特征

<img src="47期C++笔记.assets/image-20230413102344995.png" alt="image-20230413102344995" style="zoom:50%;" />

##### bound函数

<img src="47期C++笔记.assets/image-20230413102131475.png" alt="image-20230413102131475" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230413102207349.png" alt="image-20230413102207349" style="zoom:50%;" />

注意：set与multiset针对于自定义类型的写法完全等同，都可以针对于自定义类型的三种形式完全一样。

#### 3、map的使用

##### 1、基本特征

<img src="47期C++笔记.assets/image-20230413113804865.png" alt="image-20230413113804865" style="zoom:50%;" />

##### 2、初始化与遍历



<img src="47期C++笔记.assets/image-20230413110730923.png" alt="image-20230413110730923" style="zoom:60%;" /><img src="47期C++笔记.assets/image-20230413110711736.png" alt="image-20230413110711736" style="zoom:50%;" />

##### 3、查找

<img src="47期C++笔记.assets/image-20230413110801979.png" alt="image-20230413110801979" style="zoom:50%;" />

##### 4、插入

<img src="47期C++笔记.assets/image-20230413110925926.png" alt="image-20230413110925926" style="zoom:67%;" />

<img src="47期C++笔记.assets/image-20230413110949126.png" alt="image-20230413110949126" style="zoom:67%;" />

<img src="47期C++笔记.assets/image-20230413112124946.png" alt="image-20230413112124946" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230413112216472.png" alt="image-20230413112216472" style="zoom:50%;" />

##### 5、map的下标（重点）

<img src="47期C++笔记.assets/image-20230413113725105.png" alt="image-20230413113725105" style="zoom:50%;" />

##### 6、针对于自定义类型

如果自定义类型是string，是不需要重载小于符号的，因为其可以进行直接比较。

<img src="47期C++笔记.assets/image-20230413114921366.png" alt="image-20230413114921366" style="zoom:67%;" />

#### 4、multimap的使用

##### 1、特征

<img src="47期C++笔记.assets/image-20230413144132336.png" alt="image-20230413144132336" style="zoom:50%;" />

##### 2、不支持下标（重点）

<img src="47期C++笔记.assets/image-20230413144206305.png" alt="image-20230413144206305" style="zoom:50%;" />

### 三、无序关联式容器

#### 0、基本概念

底层使用的是哈希。

##### 哈希函数

通过key值找到key值存放的位置。size_t index = H(key)

##### 哈希函数的构建

目的就是为了设计哈希函数，尽量能减少冲突。

##### 哈希冲突

H(key1) = H(key2),key值不一样，但是key值对应的位置值index是一样。

##### 解决哈希冲突

开放地址法、在散列法、建立公共溢出区

链地址法（STL中使用就是这种方法）

<img src="47期C++笔记.assets/image-20230413145255823.png" alt="image-20230413145255823" style="zoom:50%;" />

##### 装载因子

装填因子。实际的数据个数/表的长度 = m。m越大的话，那么冲突的概率就比较高，但是空间的利用率也比较高。m越小的话，冲突的概率也会比较小，空间的利用率也会比较小。尽量将装载因子的大小设计在[0.5, 0.75].
可以将数组看成是完美的哈希。

#### 1、unordered_set的使用

##### 特征

<img src="47期C++笔记.assets/image-20230413151158384.png" alt="image-20230413151158384" style="zoom:50%;" />

总结：其他的查找方法与set完全相同，insert插入的方法、以及erase方法与set完全相同。也没有下标访问运算符。

##### 针对自定义类型

```C++
template<
    class Key,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator<Key>
> class unordered_set;
```

<img src="47期C++笔记.assets/image-20230413160426728.png" alt="image-20230413160426728" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230413160532819.png" alt="image-20230413160532819" style="zoom:50%;" />



针对于std::hash的写法

<img src="47期C++笔记.assets/image-20230413160011301.png" alt="image-20230413160011301" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230413160033396.png" alt="image-20230413160033396" style="zoom:50%;" />

针对于std::equal_to的写法

<img src="47期C++笔记.assets/image-20230413160121060.png" alt="image-20230413160121060" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230413160204368.png" alt="image-20230413160204368" style="zoom:50%;" />

#### 2、unordered_multiset的使用

<img src="47期C++笔记.assets/image-20230413160816600.png" alt="image-20230413160816600" style="zoom:50%;" />

注意：unordered_multiset的查找、插入、删除，可以参照set与multiset之间的区别。针对于自定义类型，完全与unordered_set等价。

#### 3、unordered_map的使用

##### 基本特征

<img src="47期C++笔记.assets/image-20230413161712905.png" alt="image-20230413161712905" style="zoom:50%;" />

##### 下标访问（重点）

<img src="47期C++笔记.assets/image-20230413161733315.png" alt="image-20230413161733315" style="zoom:50%;" />

#### 4、unordered_multimap的使用

##### 基本特征

<img src="47期C++笔记.assets/image-20230413162434211.png" alt="image-20230413162434211" style="zoom:50%;" />

##### 不支持下标

<img src="47期C++笔记.assets/image-20230413162452977.png" alt="image-20230413162452977" style="zoom:50%;" />

### 四、优先级队列

```C++
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type> //类型萃取
> class priority_queue;
```

<img src="47期C++笔记.assets/image-20230413165311904.png" alt="image-20230413165311904" style="zoom:50%;" />

#### 针对于自定义类型

针对于自定义类型的时候，需要根据第二个模板参数中容器的value_type进行std::less的改写。std::less有常规的三种形式，**模板的特化、函数对象的形式、运算符重载的形式**（在前面讲set的时候重点讲解过）。

### 五、容器的选择

#### 1、如果说容器可以取下标？

vector、deque、map、unordered_map

总结：所有只要是带set的都没有下标，所有带multi的都与下标没有关系，list没有下标。

#### 2、元素是否有序？

关联式容器是有顺序，无序关联式容器没有，对于序列式容器而言，默认情况下与顺序没有关系，但是可以借助于对应排序函数进行排序。

#### 3、时间复杂度？

无序关联式容器：底层使用的是哈希，如果没有冲突的话，时间复杂度O(1).

关联式容器：底层使用的是红黑树，时间复杂度O(logN).

序列式容器：时间复杂度O(N)

#### 4、迭代器的类型？

随机访问迭代器：vector、deque

双向迭代器：list、关联式容器。

前向迭代器：无序关联式容器。

没有迭代器：容器适配器stack、queue、priority_queue

## C++Day23

### 一、问题回顾

1、容器的基本操作，初始化、遍历、查找（count、find）、插入、删除、下标访问、清空、swap、empty、size、emplace等等。

2、针对于自定义类型的写法？

3、关联式容器的底层实现是什么？无序关联式容器的底层实现是什么？

4、优先级队列的底层实现是什么？原理是什么？

5、如何选择容器？

### 二、流迭代器

输入输出流之所以可以看成是容器，因为会对应的有缓冲区，而缓冲区是可以存数据的，就可以当容器看待。

迭代器的头文件在  #include <iterator>

![image-20230414164033379](47期C++笔记.assets/image-20230414164033379.png)

#### 1、输出流迭代器

<img src="47期C++笔记.assets/image-20230414111830585.png" alt="image-20230414111830585" style="zoom:67%;" />

```C++
Defined in header <algorithm>

template< class InputIt, class OutputIt >
OutputIt copy( InputIt first, InputIt last, OutputIt d_first );
```

```C++
class ostream_iterator
{
public:
    //ostream_iterator<int>  osi(cout, "\n");
    //ostream_type& __s = cout;  _M_stream = &cout;
    //const _CharT* __c = "\n";_M_string = "\n"
    ostream_iterator(ostream_type& __s, const _CharT* __c) 
    : _M_stream(&__s)
    , _M_string(__c)  
    {
        
    }
    
    //osi = 1
    //__value = 1;
    //__Tp = int
    ostream_iterator<_Tp>& operator=(const _Tp& __value) 
    { 
        *_M_stream << __value;//cout << 1
        if (_M_string) 
            *_M_stream << _M_string;//cout << "\n"
        return *this;
    }
    ostream_iterator<_Tp>& operator*() 
    { 
        return *this; 
    }
    ostream_iterator<_Tp>& operator++() 
    { 
        return *this; 
    } 
    ostream_iterator<_Tp>& operator++(int) 
    { 
        return *this; 
    } 
private:
    ostream_type* _M_stream;
    const _CharT* _M_string;  
};
```

```C++
template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) 
{
  return __copy_aux(__first, __last, __result, __VALUE_TYPE(__first));
}

template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last,
                              _OutputIter __result, _Tp*) 
{
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator  _Trivial;
  return __copy_aux2(__first, __last, __result, _Trivial());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux2(_InputIter __first, _InputIter __last,
                               _OutputIter __result, __false_type) 
{
  return __copy(__first, __last, __result,
                __ITERATOR_CATEGORY(__first),
                __DISTANCE_TYPE(__first));
}

template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          input_iterator_tag, _Distance*)
{
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}


//vector<int> vec = {1, 3, 5, 9, 7};
//copy(vec.begin(), vec.end(), osi)
__first = vec.begin();
__last = vec.end();
__result = osi
_OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          input_iterator_tag, _Distance*)
{
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;//osi = 3
  return __result;
}
              last
1, 3, 5, 9, 7
              f
                  
    //osi = 1
    //__value = 1;3
    //__Tp = int
    ostream_iterator<_Tp>& operator=(const _Tp& __value) 
    { 
        *_M_stream << __value;//cout << 3
        if (_M_string) 
            *_M_stream << _M_string;//cout << "\n"
        return *this;
    }   
```

#### 2、输入流迭代器

<img src="47期C++笔记.assets/image-20230414143614992.png" alt="image-20230414143614992" style="zoom:67%;" />

##### ==gdb的使用（重点）==

list，简写为l，查看代码；breakpoint，简写为b，设置断点的；run，简写为r，让程序跑起来；step，简写为s，单步调试；next，简写为n，下一步；info b,查看断点；bt打印堆栈信息；print，简写为p，可以打印变量的值；ptype，可以打印变量类型。

```C++
class istream_iterator
{
public:
    istream_iterator() 
    : _M_stream(0)
    , _M_ok(false) {}
    //istream_iterator<int> isi(cin)
    //istream_type& __s = cin;
    //_M_stream = &cin;
    istream_iterator(istream_type& __s) 
    : _M_stream(&__s) 
    { 
        _M_read(); 
    }
    
     void _M_read() 
     {
         _M_ok = (_M_stream && *_M_stream) ? true : false;
         if (_M_ok) 
         {
             *_M_stream >> _M_value;//cin >> _M_value  2
             _M_ok = *_M_stream ? true : false;
         }
     }
     reference operator*() const 
     { 
         return _M_value; 
     }
    
     istream_iterator& operator++() 
     { 
         _M_read(); 
         return *this;
     }
    istream_iterator operator++(int)  {
    istream_iterator __tmp = *this;
    _M_read();
    return __tmp;
  }
    //isi
    //__x = istream_iterator<int>()
   bool _M_equal(const istream_iterator& __x) const
   { 
       //_M_ok = 0;
       return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); 
   }
private:
    istream_type* _M_stream;
    _Tp _M_value;
    bool _M_ok;
};

//__first = isi = __x;
//__last = istream_iterator<int>() = __y;
template <class _Tp, class _CharT, class _Traits, class _Dist>
inline bool 
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) {
  return !__x._M_equal(__y);
}

```

```C++
//__first = isi;
//__last = istream_iterator<int>();
//__result = back_insertter(vec);
_OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          input_iterator_tag, _Distance*)
{
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}

*__result   = 1;
*__result   = 2;
    
template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}
Point back_inserter(_Container& __x)
{
    return Point(x);
}
```

```C++
class back_insert_iterator 
{
public:
    explicit back_insert_iterator(_Container& __x) 
    : container(&__x) 
    {}
    
    back_insert_iterator<_Container>& 
    operator=(const typename _Container::value_type& __value) 
    { 
        container->push_back(__value);
        return *this;
    }
    
    back_insert_iterator<_Container>& operator*() { return *this; }
    back_insert_iterator<_Container>& operator++() { return *this; }
    back_insert_iterator<_Container>& operator++(int) { return *this; }
protected:
  _Container* container;
}
```

### 三、插入迭代器

<img src="47期C++笔记.assets/image-20230414162756653.png" alt="image-20230414162756653" style="zoom: 50%;" /><img src="47期C++笔记.assets/image-20230414162836210.png" alt="image-20230414162836210" style="zoom:55%;" />

### 四、反向迭代器

<img src="47期C++笔记.assets/image-20230414163130982.png" alt="image-20230414163130982" style="zoom:67%;" /><img src="47期C++笔记.assets/image-20230414163958175.png" alt="image-20230414163958175" style="zoom:50%;" />

### 五、算法

#### 分类

1、非修改式的算法，例如：count、find、**for_each**

2、修改式的算法，例如：**copy**、**remove_if**、replace、fill、swap

3、排序的算法，例如：**sort**、**lower_bound**、upper_bound

4、集合算法，例如：**set_intersection**、set_difference、set_union

5、堆的算法，例如：make_heap

6、取最值算法，例如：max、min

7、数值算法，例如：iota、accumulate

8、内存未初始化的算法，例如：**uninitialized_copy**

9、C中的算法，例如：qsort

#### for_each的使用

```C++
template< class InputIt, class UnaryFunction >
UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );
```

一元函数：函数的参数是一个。二元函数：函数的参数是两个。

一元断言（谓词）：函数的参数是一个，并且函数的返回类型是bool。
二元断言（谓词）：函数的参数是两个，并且函数的返回类型是bool。

<img src="47期C++笔记.assets/image-20230414172331327.png" alt="image-20230414172331327" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230414173626707.png" alt="image-20230414173626707" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230414175003175.png" alt="image-20230414175003175" style="zoom:50%;" />

## C++Day24

### 一、问题回顾

1、作业编程题居多，要注意多写。（随着知识点增多，作业难度偏大，要注意心理落差）

2、输入输出流迭代器的源码？三对插入迭代器的源码阅读，底层分别使用了什么？

3、算法分为哪些类别？

### 二、remove_if算法

```C++
template<class InputIt, class UnaryPredicate>
constexpr InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
{
    for (; first != last; ++first) {
        if (p(*first)) {
            return first;
        }
    }
    return last;
}

template<class ForwardIt, class UnaryPredicate>
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p)
{
    first = std::find_if(first, last, p);
    if (first != last)
        for(ForwardIt i = first; ++i != last; )
            if (!p(*i))
                *first++ = std::move(*i);
    return first;
}

bool func(int value)
{
    return value > 5;
}
                       last
1, 3, 5, 7, 5, 8, 9, 2
         f
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
{
    for (; first != last; ++first) 
    {
        if (p(*first)) 
        {
            return first;
        }
    }
    return last;
}

//vector<int> vec = {1, 3, 5, 7, 5, 8, 9, 2};
//remove_if(vec.begin(), vec.end(), func);

bool func(int value)
{
    return value > 5;
}
//first = vec.begin();
//last = vec.end();
//p = func
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p)
{
    first = std::find_if(first, last, p);
    if (first != last)
    {
        for(ForwardIt i = first; ++i != last; )
        {
             if (!p(*i))
             {
                 *first++ = std::move(*i);                
             }                    
        }        
    }
        
    return first;
}
               f        last
1, 3, 5, 5, 2, 8, 9, 2
                        i      
```



<img src="47期C++笔记.assets/image-20230415103109105.png" alt="image-20230415103109105" style="zoom:50%;" />



```C++
//如果将func的第二个参数进行固定，那么func就应该具备大于符号的含义，那func就可以是greater
bool func(int lhs, int rhs = 5)
{
    return lhs > 5;
}

//如果将func的第一个参数进行固定，那么func就应该具备小于符号的含义，那func就可以是less
bool func(int lhs = 5, int rhs)
{
    return 5 < rhs;
}

struct greater
{
    bool operator()(const int &lhs, const int &rhs = 5) const
    {
        return lhs > rhs = 5;
    }
}

```

### 三、bind的使用(重要)

<img src="47期C++笔记.assets/image-20230415111415863.png" alt="image-20230415111415863" style="zoom:67%;" />

bind1st可以绑定二元函数对象f的第一个参数（也就是固定第一个参数），bind2nd可以绑定二元函数对象的第二个参数（也就是固定第二个参数）。

<img src="47期C++笔记.assets/image-20230415111516585.png" alt="image-20230415111516585" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230415111932621.png" alt="image-20230415111932621" style="zoom: 67%;" />

<img src="47期C++笔记.assets/image-20230415120508068.png" alt="image-20230415120508068" style="zoom:50%;" /><img src="47期C++笔记.assets/image-20230415120451074.png" alt="image-20230415120451074" style="zoom:50%;" />

#### 函数指针

<img src="47期C++笔记.assets/image-20230415115550610.png" alt="image-20230415115550610" style="zoom:50%;" />

## C++Day25

### 一、bind的使用（重要）

#### 占位符的特征

<img src="47期C++笔记.assets/image-20230417100423710.png" alt="image-20230417100423710" style="zoom:60%;" />

#### ==重点，难点==

<img src="47期C++笔记.assets/image-20230417103050677.png" alt="image-20230417103050677" style="zoom:50%;" />

### 二、function的使用（重要）

<img src="47期C++笔记.assets/image-20230417101151707.png" alt="image-20230417101151707" style="zoom:67%;" />

<img src="47期C++笔记.assets/image-20230417142445581.png" alt="image-20230417142445581" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230417102319977.png" alt="image-20230417102319977" style="zoom:50%;" />

使用bind与function结合使用，使用了面向过程实现多态。

### 三、成员函数适配器mem_fn

<img src="47期C++笔记.assets/image-20230417115505460.png" alt="image-20230417115505460" style="zoom:50%;" />

<img src="47期C++笔记.assets/image-20230417143811482.png" alt="image-20230417143811482" style="zoom:50%;" />

### 四、函数对象（仿函数）

**可以与小括号进行结合体现函数的含义的，统称为函数对象**

1、重载了函数调用运算符的类创建的对象。

2、函数名

3、函数指针。

### 五、空间配置器（重难点）

#### 基本概念

将空间的申请与对象的构建分开了，将空间的释放与对象的销毁分开了。

```C++
Point pt(1, 2);
```

对于STL中，容器可能一次需要存多个元素，需要将空间的申请与对象的构建分开，不然就变成了申请一块空间，创建一个对象，频繁进行操作。

#### 基本使用

```C++
//申请未初始化的空间
pointer allocate( size_type n, const void * hint = 0 );

//回收空间
void deallocate( T* p, std::size_t n );

//构建对象
void construct( pointer p, const_reference val );

//对象的销毁
void destroy( pointer p );
```

一自定义的MyVector为例，看看代码实现。

#### 原理

16个自由链表 + 内存池。

<img src="47期C++笔记.assets/image-20230417181221377.png" alt="image-20230417181221377" style="zoom:50%;" />

#### 源码

```C++
//第一级空间配置器
# ifdef __USE_MALLOC
typedef malloc_alloc alloc;
typedef __malloc_alloc_template<0> malloc_alloc;
class __malloc_alloc_template 
{
public:
	static void* allocate(size_t __n)
	{
      void* __result = malloc(__n);
      if (nullptr == __result) 
        __result = _S_oom_malloc(__n);//oom = out of memory

      return __result;
    }

    static void deallocate(void* __p, size_t /* __n */)
    {
		free(__p);
    }
};
#else
//第二级空间配置器（默认的空间配置器）
typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;
class __default_alloc_template 
{
public:
    static void* allocate(size_t __n)
    {
		if(__n > 128)
		{
			malloc(__n);
		}
		else
		{
			//16个自由链表 + 内存池
		}
	}

};

#endif

class allocator 
{
	typedef alloc _Alloc;
public:
	_Tp* allocate(size_type __n, const void* = nullptr) 
	{
		return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) : 0;
	}

    // __p is not permitted to be a null pointer.
    void deallocate(pointer __p, size_type __n)
    { 
		_Alloc::deallocate(__p, __n * sizeof(_Tp)); 
	}
	
	//构建对象
	void construct(pointer __p, const _Tp& __val) 
	{ 
	    //new Point(1, 2)
		new(__p) _Tp(__val); //定位new表达式
	}
	//对象的销毁
    void destroy(pointer __p) 
	{ 
		__p->~_Tp(); 
	}
};







enum {_ALIGN = 8};
enum {_MAX_BYTES = 128};
enum {_NFREELISTS = 16}; 

union _Obj 
{
	union _Obj* _M_free_list_link;
    char _M_client_data[1];    /* The client sees this.        */
};


//__bytes = 32
static  size_t _S_freelist_index(size_t __bytes) 
{
	return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);
	(32 + 8 - 1)/8 - 1 = 39/8 - 1 = 4.x - 1 = 3.x = 3
}

//__bytes = 32
//[25, 32]  ==== 32
25/8 = 3.x  32/8 = 4   32
//向上取整，得到8的整数倍
static size_t _S_round_up(size_t __bytes) 
{ 
    return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1));
        (32 + 8 - 1) & ~ (8 - 1);
		39 & ~7
		7 = 0000 0111
		~7 = 1111 1000
		
		39 = 32 + 4 + 2 + 1
		39 = 0010 0111
		
		0010 0111
	&	1111 1000
	    0010 0000  = 32
		
		0010 0110
	&	1111 1000
	    0010 0000  = 32
		
		0010 0000
	&	1111 1000
	    0010 0000  = 32
		
		0001 1111
	&	1111 1000
	    0001 1000  = 24
		
		0010 1000
	&	1111 1000
	    0010 1000  = 40
}

template <bool __threads, int __inst>
typename __default_alloc_template<__threads, __inst>::_Obj* __STL_VOLATILE
__default_alloc_template<__threads, __inst> ::_S_free_list[
# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)
    _NFREELISTS
# else
    __default_alloc_template<__threads, __inst>::_NFREELISTS
# endif
] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };


template <bool __threads, int __inst>
char* __default_alloc_template<__threads, __inst>::_S_start_free = nullptr;

template <bool __threads, int __inst>
char* __default_alloc_template<__threads, __inst>::_S_end_free = nullptr;

template <bool __threads, int __inst>
size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;





//1、申请32字节时候，保证空间是足够的
//__size = 32, __nobjs = 20
char* __default_alloc_template::_S_chunk_alloc(size_t __size, int& __nobjs)
{
    char* __result;
    size_t __total_bytes = __size * __nobjs = 32 * 20 = 640;
    size_t __bytes_left = _S_end_free - _S_start_free = 0;
	
	else
	{
		 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size >> 4)
		                            = 2 * 640  = 1280;
		_S_start_free = (char*)malloc(__bytes_to_get) = malloc(1280);
						  
		_S_heap_size += __bytes_to_get = 1280;
        _S_end_free = _S_start_free + __bytes_to_get;
        return(_S_chunk_alloc(__size, __nobjs));
	}
	//递归调用_S_chunk_alloc
	char* __result;
    size_t __total_bytes = __size * __nobjs = 32 * 20 = 640;
    size_t __bytes_left = _S_end_free - _S_start_free = 1280;
	
	 if (__bytes_left >= __total_bytes) 
	 {
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        return(__result);
    }
}

//__n = 32
void* __default_alloc_template::_S_refill(size_t __n)
{
	int __nobjs = 20;
    char* __chunk = _S_chunk_alloc(__n, __nobjs);
	_Obj** __my_free_list;
    _Obj* __result;
    _Obj* __current_obj;
    _Obj* __next_obj;
    int __i;
	
	__my_free_list = _S_free_list + _S_freelist_index(__n);//_S_free_list[3]
	
	__result = (_Obj*)__chunk;
    *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
      for (__i = 1; ; __i++) 
	  {
        __current_obj = __next_obj;
        __next_obj = (_Obj*)((char*)__next_obj + __n);
        if (__nobjs - 1 == __i) {
            __current_obj -> _M_free_list_link = 0;
            break;
        } else {
            __current_obj -> _M_free_list_link = __next_obj;
        }
}

//__n = 32
static void* allocate(size_t __n)
{
	else
	{
		_Obj** __my_free_list = _S_free_list + _S_freelist_index(__n);//_S_free_list[3]
		
		_Obj*  __result = *__my_free_list;
        if (__result == nullptr)
			__ret = _S_refill(_S_round_up(__n));
        else 
		{
			*__my_free_list = __result -> _M_free_list_link;
			__ret = __result;
        }
	}
}



//2、申请64字节时候，保证空间是足够的
//__size = 64,__nobjs = 20
char*__default_alloc_template::_S_chunk_alloc(size_t __size, int& __nobjs)
{
    char* __result;
    size_t __total_bytes = __size * __nobjs = 64 * 20 = 1280;
    size_t __bytes_left = _S_end_free - _S_start_free = 640;
	
	else if (__bytes_left >= __size) 
	{
        __nobjs = (int)(__bytes_left/__size) = 640/64 = 10;
        __total_bytes = __size * __nobjs = 64 * 10 = 640;
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        return(__result);
    }
}

//__n = 64
void* __default_alloc_template::_S_refill(size_t __n)
{
    int __nobjs = 20;
    char* __chunk = _S_chunk_alloc(__n, __nobjs);
    _Obj* __STL_VOLATILE* __my_free_list;
    _Obj* __result;
    _Obj* __current_obj;
    _Obj* __next_obj;
    int __i;
	
	 __my_free_list = _S_free_list + _S_freelist_index(__n);//_S_free_list[7]

 
      __result = (_Obj*)__chunk;
      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
      for (__i = 1; ; __i++) 
	  {
        __current_obj = __next_obj;
        __next_obj = (_Obj*)((char*)__next_obj + __n);
        if (__nobjs - 1 == __i) 
		{
            __current_obj -> _M_free_list_link = 0;
            break;
        } else {
            __current_obj -> _M_free_list_link = __next_obj;
        }
      }

}

//__n = 64
static void* allocate(size_t __n)
{
    void* __ret = 0;
	else 
	{
      _Obj* * __my_free_list = _S_free_list + _S_freelist_index(__n);//_S_free_list[7]
	  _Obj*  __result = *__my_free_list;
      if (__result == 0)
        __ret = _S_refill(_S_round_up(__n));
      else {
        *__my_free_list = __result -> _M_free_list_link;
        __ret = __result;
      }
	}
}


//3、申请96字节时候，保证空间是足够的
//__size = 96,__nobjs = 20
char*__default_alloc_template::_S_chunk_alloc(size_t __size, int& __nobjs)
{
    char* __result;
    size_t __total_bytes = __size * __nobjs = 96 * 20 = 1920;
    size_t __bytes_left = _S_end_free - _S_start_free = 0;
	
	else {
        size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size >> 4)
		                           = 2 * 1920 + _S_round_up(1280 >> 4)
								   = 3840 + 80 = 3920;
		 _S_start_free = (char*)malloc(__bytes_to_get) = malloc(3920);
		 
		 _S_heap_size += __bytes_to_get = 1280 + 3920 = 5200;
        _S_end_free = _S_start_free + __bytes_to_get;
        return(_S_chunk_alloc(__size, __nobjs));
	}
	//递归调用_S_chunk_alloc
	 char* __result;
    size_t __total_bytes = __size * __nobjs = 96 * 20 = 1920;;
    size_t __bytes_left = _S_end_free - _S_start_free = 3920;
	
	if (__bytes_left >= __total_bytes) 
	{
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        return(__result);
    }
	
}
//__n = 96
void* __default_alloc_template::_S_refill(size_t __n)
{
    int __nobjs = 20;
    char* __chunk = _S_chunk_alloc(__n, __nobjs);
    _Obj* __STL_VOLATILE* __my_free_list;
    _Obj* __result;
    _Obj* __current_obj;
    _Obj* __next_obj;
    int __i;
	
	 __my_free_list = _S_free_list + _S_freelist_index(__n);//_S_free_list[11]

    /* Build free list in chunk */
      __result = (_Obj*)__chunk;
      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
      for (__i = 1; ; __i++) {
        __current_obj = __next_obj;
        __next_obj = (_Obj*)((char*)__next_obj + __n);
        if (__nobjs - 1 == __i) {
            __current_obj -> _M_free_list_link = 0;
            break;
        } else {
            __current_obj -> _M_free_list_link = __next_obj;
        }
      }
}
//__n = 96
static void* allocate(size_t __n)
{
    void* __ret = 0;
	else 
	{
      _Obj* * __my_free_list = _S_free_list + _S_freelist_index(__n);//_S_free_list[11]
	  _Obj*  __result = *__my_free_list;
      if (__result == nullptr)
        __ret = _S_refill(_S_round_up(__n));
      else {
        *__my_free_list = __result -> _M_free_list_link;
        __ret = __result;
      }
	}
}


//4、申请72字节时候，内存池与堆空间都没有连续的72字节
//此时72字节是从96字节借过来。
//__size = 72,__nobjs = 20
char*__default_alloc_template::_S_chunk_alloc(size_t __size, int& __nobjs)
{
    char* __result;
    size_t __total_bytes = __size * __nobjs = 72 * 20 = 1440;
    size_t __bytes_left = _S_end_free - _S_start_free = 0;
	
	else {
        size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size >> 4)
		                           = 2 * 1440 + _S_round_up(5200 >> 4) > 2880;
		_S_start_free = (char*)malloc(__bytes_to_get);
		 if (0 == _S_start_free) 
		 {
            size_t __i;
            _Obj* * __my_free_list;
	        _Obj* __p;
			
			//__size = 72,_MAX_BYTES = 128,_ALIGN = 8
			//72 80  88  96
			////_S_free_list[8]   _S_free_list[9]  _S_free_list[10]  _S_free_list[11]
			for (__i = __size; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) 
			{
				__my_free_list = _S_free_list + _S_freelist_index(__i);//_S_free_list[11]
                __p = *__my_free_list;
				
				if (0 != __p) {
                    *__my_free_list = __p -> _M_free_list_link;
                    _S_start_free = (char*)__p;
                    _S_end_free = _S_start_free + __i;
                    return(_S_chunk_alloc(__size, __nobjs));
                    // Any leftover piece will eventually make it to the
                    // right free list.
                }
			}
		 }
	}
	//递归调用_S_chunk_alloc
	 char* __result;
    size_t __total_bytes = __size * __nobjs = 72 * 20 = 1440;
    size_t __bytes_left = _S_end_free - _S_start_free = 96;
	
	else if (__bytes_left >= __size) 
	{
        __nobjs = (int)(__bytes_left/__size) = 1;
        __total_bytes = __size * __nobjs = 72 ;
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        return(__result);
    }

}


//__n = 72
void* __default_alloc_template::_S_refill(size_t __n)
{
    int __nobjs = 20;
    char* __chunk = _S_chunk_alloc(__n, __nobjs);
    _Obj* __STL_VOLATILE* __my_free_list;
    _Obj* __result;
    _Obj* __current_obj;
    _Obj* __next_obj;
    int __i;
	
	if (1 == __nobjs) return(__chunk);
}


//__n = 72
static void* allocate(size_t __n)
{
    void* __ret = 0;
	else 
	{
      _Obj* * __my_free_list = _S_free_list + _S_freelist_index(__n);//_S_free_list[8]
	  _Obj*  __result = *__my_free_list;
      if (__result == nullptr)
        __ret = _S_refill(_S_round_up(__n));
      else {
        *__my_free_list = __result -> _M_free_list_link;
        __ret = __result;
      }
	}
}
```

